<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>图论(一):BFS,DFS,MST,Dijkstra | Mozi&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文归纳图论的知识点。
图一般用G = (V, E)表示。连接顶点u和v的边用{u, v}表示。连通图：图中任意两点都连通，即存在路径以它们为始终点。有向图：图中每个边都有方向，无向图相当于是每条边都有正反两个方向的有向图。环：一条路径的起止点事一样的。无环图(acycle)：图中没有环
图的邻接链表
为每个顶点链接上它所有相连的顶点。
宽度优先搜索(BFS)从一个顶点b开始等深度地遍历所有连通的">
<meta property="og:type" content="article">
<meta property="og:title" content="图论(一):BFS,DFS,MST,Dijkstra">
<meta property="og:url" content="https://mozi030.github.io/2017/04/24/图论-一/index.html">
<meta property="og:site_name" content="Mozi's Blog">
<meta property="og:description" content="本文归纳图论的知识点。
图一般用G = (V, E)表示。连接顶点u和v的边用{u, v}表示。连通图：图中任意两点都连通，即存在路径以它们为始终点。有向图：图中每个边都有方向，无向图相当于是每条边都有正反两个方向的有向图。环：一条路径的起止点事一样的。无环图(acycle)：图中没有环
图的邻接链表
为每个顶点链接上它所有相连的顶点。
宽度优先搜索(BFS)从一个顶点b开始等深度地遍历所有连通的">
<meta property="og:image" content="https://mozi030.github.io/2017/04/24/图论-一/basic1.png">
<meta property="og:image" content="https://mozi030.github.io/2017/04/24/图论-一/bfs1.png">
<meta property="og:image" content="https://mozi030.github.io/2017/04/24/图论-一/dfs1.png">
<meta property="og:image" content="https://mozi030.github.io/2017/04/24/图论-一/Articulation_Point1.png">
<meta property="og:image" content="https://mozi030.github.io/2017/04/24/图论-一/dijkstra1.png">
<meta property="og:image" content="https://mozi030.github.io/2017/04/24/图论-一/dijkstra2.png">
<meta property="og:image" content="https://mozi030.github.io/2017/04/24/图论-一/Floyd-Warshall1.png">
<meta property="og:updated_time" content="2017-05-04T03:57:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="图论(一):BFS,DFS,MST,Dijkstra">
<meta name="twitter:description" content="本文归纳图论的知识点。
图一般用G = (V, E)表示。连接顶点u和v的边用{u, v}表示。连通图：图中任意两点都连通，即存在路径以它们为始终点。有向图：图中每个边都有方向，无向图相当于是每条边都有正反两个方向的有向图。环：一条路径的起止点事一样的。无环图(acycle)：图中没有环
图的邻接链表
为每个顶点链接上它所有相连的顶点。
宽度优先搜索(BFS)从一个顶点b开始等深度地遍历所有连通的">
<meta name="twitter:image" content="https://mozi030.github.io/2017/04/24/图论-一/basic1.png">
  
    <link rel="alternate" href="/atom.xml" title="Mozi&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mozi&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mozi030.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-图论-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/24/图论-一/" class="article-date">
  <time datetime="2017-04-24T15:36:29.000Z" itemprop="datePublished">2017-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      图论(一):BFS,DFS,MST,Dijkstra
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文归纳图论的知识点。</p>
<p>图一般用G = (V, E)表示。连接顶点u和v的边用{u, v}表示。<br>连通图：图中任意两点都连通，即存在路径以它们为始终点。<br>有向图：图中每个边都有方向，无向图相当于是每条边都有正反两个方向的有向图。<br>环：一条路径的起止点事一样的。<br>无环图(acycle)：图中没有环</p>
<h4 id="图的邻接链表"><a href="#图的邻接链表" class="headerlink" title="图的邻接链表"></a>图的邻接链表</h4><img src="/2017/04/24/图论-一/basic1.png" alt="basic1.png" title="">
<p>为每个顶点链接上它所有相连的顶点。</p>
<h3 id="宽度优先搜索bfs"><a href="#宽度优先搜索-BFS" class="headerlink" title="宽度优先搜索(BFS)"></a>宽度优先搜索(BFS)</h3><p>从一个顶点b开始等深度地遍历所有连通的顶点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">queue</span>&lt;Node&gt;q;</div><div class="line">q.push(b);</div><div class="line"><span class="keyword">while</span> (!q.empty()) &#123;</div><div class="line">  Node cur_node = q.front();</div><div class="line">  q.pop();</div><div class="line">  <span class="comment">// do something with cur_node</span></div><div class="line">  <span class="keyword">for</span> (Node next : cur_node.all_next()) &#123;</div><div class="line">    <span class="keyword">if</span> (uncheck(next)) &#123;</div><div class="line">      q.push(next);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若不连通的顶点也要遍历的话，在每次遇到q为empty的时候都检查还有没有顶点是unchecked，若有则push进q再遍历，直到所有顶点都checked。<br>每个顶点都会插入到q一次，并从q中删除一次；每条边都会被遍历两次（分别从两个顶点，若在有向图中则只有一次）。时间复杂度是O(V + E)。</p>
<h4 id="bfs-tree"><a href="#BFS-Tree" class="headerlink" title="BFS Tree"></a>BFS Tree</h4><img src="/2017/04/24/图论-一/bfs1.png" alt="bfs1.png" title="">
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>(1)找图的连通部分。<br>(2)找点v1到点v2之间的所有路径。（记录每个路径走过的点，不走重复点）。<br>(3)找点v1到点v2之间的最短路径。（第一个找到的路径即为最短。）</p>
<h3 id="深度优先搜索dfs"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p>沿一个路径不断往深遍历，直到尽头（没有unchecked的点），再逐步回溯。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> prev_node[v_num];</div><div class="line"><span class="keyword">bool</span> checked[v_num];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">memset</span>(prev_node, <span class="number">-1</span>, <span class="keyword">sizeof</span>(prev_node));</div><div class="line">  <span class="built_in">memset</span>(checked, <span class="literal">false</span>, <span class="keyword">sizeof</span>(checked));</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_num; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (!checked[i]) &#123;</div><div class="line">      DFS_visit(i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_visit</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">  checked[index] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> next : v[index].all_next()) &#123;</div><div class="line">    <span class="keyword">if</span> (!checked[next]) &#123;</div><div class="line">      prev[next] = index;</div><div class="line">      DFS_visit(index);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DFS是基于stack实现的，上例用函数栈来代替stack，当然也可以直接用stack来实现。<br>若stack为empty，push下一个unchecked的点，若不为empty，去栈顶元素，并push这个元素的所有unchecked的next。<br>若要记录深度depth或step，要不在stack中存储的Node结构体中加入成员，要不在函数内传参，并在DFS_visit前后为depth++，和–。</p>
<p>每个顶点将被遍历一次，每条边被遍历一次。所以时间复杂度是O(V + E)。</p>
<h4 id="dfs-tree"><a href="#DFS-Tree" class="headerlink" title="DFS Tree"></a>DFS Tree</h4><img src="/2017/04/24/图论-一/dfs1.png" alt="dfs1.png" title="">
<h3 id="关节点articulation-point"><a href="#关节点-Articulation-Point" class="headerlink" title="关节点(Articulation Point)"></a>关节点(Articulation Point)</h3><p>在无向连通图中，一个点是关节点，iff删除这个点后原图被分为若干个连通图。<br>1.The leaves of a DFS tree are not articulartion points.<br>2.The root is not a articulation point iff it has at most one child.<br>3.Vertex d is not an articulation point iff there are back edges that connect every subtree rooted at a child of d to an ancestor of d.<br><img src="/2017/04/24/图论-一/Articulation_Point1.png" alt="Articulation_Point1.png" title=""><br>时间复杂度为O(n<sup>2</sup>)。</p>
<h3 id="生成树spanning-tree"><a href="#生成树-spanning-tree" class="headerlink" title="生成树(spanning tree)"></a>生成树(spanning tree)</h3><p>G的生成树是一个G的无环连通子图，且包含G的所有点V。<br>一颗生成树的权重是生成树中所有边的权重之和。<br>G中存在n个顶点的话，那么生成树中就有(n - 1)条边。</p>
<h4 id="最小生成树minimal-spanning-treemst"><a href="#最小生成树-minimal-spanning-tree-MST" class="headerlink" title="最小生成树(minimal spanning tree,MST)"></a>最小生成树(minimal spanning tree,MST)</h4><p>是G的权重最小的生成树。</p>
<h5 id="kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><p>设G施一个无向图，<br>(1)将图中所有边按权重的升序排序。<br>(2)不断遍历这些排好序的边，并维护一个forest F，且保证F是G的子图。<br>(3)F的初始状态是V，即只含G的所有顶点。<br>(4)不断选取边加入到F中，并保证每次加入都不会生成环，否则跳过这条边。<br>(5)直到F中插入了(n - 1)条边。<br>要保证无环，则要为F中所有连通部分分别取一个id，而同一连通部分中所有顶点的id是相同的。每个顶点的起始id是该顶点的id，若加入某条边时检查两个顶点的id是否一样，若不一样则另顶点较少的连通部分的id全部置为顶点较多的部分的id。</p>
<h6 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h6><p>用数学归纳法：证每次插入边后形成的forest F都是G的MST的子图。<br>(1)初始状态只含所有顶点，明显是MST的子图。<br>(2)若已知当前的F是MST的子图，要插入的下一条边为e，根据Kruskal算法，e将会把当前F中的两棵不连通的树T1，T2连通。现用反证法证插入e后，也会生成MST的子图。<br>(3)若e不属于MST，则{e} ∪ MST后会导致MST成环C，因MST是所有顶点连通的。C中包含e，T1和T2的一部分，以及在e之后将会插入的一些边e’，因T1，T2并不连通。因为e比e’中所有边的权重都小，所以将e代替e’中任意一边都能生成更小的MST，所以矛盾。</p>
<p>时间复杂度：<br>排序需要mlog(m) = mlog(n)<br>当一个顶点的id要变化时，其所在连通部分的大小至少要double。所以一个顶点的id最多变化log<sub>2</sub>n次，所以所有顶点id变化的时间复杂度是nlog(n)。<br>总时间复杂度是mlog(n) + nlog(n) = mlog(n)。</p>
<h3 id="shortest-path"><a href="#Shortest-Path" class="headerlink" title="Shortest Path"></a>Shortest Path</h3><h4 id="dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>在带权图中找一条weight最小的path，但这要求所有weight非零。设起点为s。</p>
<h5 id="shortest-path-tree"><a href="#Shortest-Path-Tree" class="headerlink" title="Shortest Path Tree"></a>Shortest Path Tree</h5><p>将从s到任意点的shortest path都找出来，并求这些path的union。若有两个path分别以边e和边e’经过顶点u，那么我们将删除e或e’，来使union中没有环。<br><img src="/2017/04/24/图论-一/dijkstra1.png" alt="dijkstra1.png" title=""><br>有了shortest path tree后，从s到任意点的shortest path就是在tree中s到任意点的path。<br>注意若图是有向的，那么shortest path tree只能代表从s到任意点的shortest path，而不代表从任意点到s的path。要求从点a到其他点的shortest path，那么就要从点a建shortest path tree。<br>Dijkstra就是用来生成shortest path tree的。</p>
<h5 id="algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h5><p>维护一个数组D[v]来表示从s到v的最小cost(s ≠ v)。<br>维护数组prev[v]来表示v在shortest path中的前一个顶点。<br><img src="/2017/04/24/图论-一/dijkstra2.png" alt="dijkstra2.png" title=""><br>用w(u,v)来表示边(u,v)的权重，若不存在边(u,v)则w(u,v) = +∞。<br>Q是包含所有顶点的set。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> i &lt; node_num; i++) &#123;</div><div class="line">  D[i] = +∞;</div><div class="line">  prev[i] = null;</div><div class="line">  Q.push(i);</div><div class="line">&#125;</div><div class="line">D[s] = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (!Q.empty())) &#123;</div><div class="line">  index = extract_min_D_from_Q(); <span class="comment">// get the min D[index] from Q, and then remove</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> next : Q) &#123;</div><div class="line">    <span class="keyword">if</span> (D[next] &gt; D[index] + w(index, next)) &#123;</div><div class="line">      D[next] = D[index] + w(index, next);</div><div class="line">      prev[next] = index;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>普通实现的时间复杂度是O(n<sup>2</sup>)<br>优化方案：用平衡树来存储Q，Q的比较函数设为用D[i]的大小来比较。那么插入，删除，查询都只需要O(log(n))。更新D[i]相当于先从Q中删除D[i]再插入新的D[i]，也是需要O(log(n))。<br>建树和n次查询、删除需要nlog(n)时间，在每一条边上都可能更新D[i]一次，所以更新的时间为mlog(n)。<br>总时间复杂度是nlog(n) + mlog(n) = mlog(n)。当m小于n<sup>2</sup>/log(n)时，优化方案会比较快。</p>
<h4 id="任意点到任一点的shortest-pathall-pairs-of-shortest-path"><a href="#任意点到任一点的shortest-path-All-Pairs-of-Shortest-Path" class="headerlink" title="任意点到任一点的shortest path(All Pairs of Shortest Path)"></a>任意点到任一点的shortest path(All Pairs of Shortest Path)</h4><p>设G为带权有向图，= {V, E}。<br>对任意边(u, v)， 求δ(u, v) = 从u到v的shortest path。<br>若所有weight都是非负的，则使用Dijkstra可得复杂度为O(n<sup>3</sup>)或O(n<sup>2</sup>log(n) + mnlog(n))。<br>但是当存在负weight的时候则不能使用Dijkstra了。</p>
<p>首先，不存在负环(negative cycle)，因不断遍历负环就可以让weight无限小，就没有shortest path一说了。所以shortest path是指weight最小且不经过负环的path，或者说weight最小且不经过重复点的path。也因此，path中最多有n-1条边。</p>
<h5 id="algorithm1-动态规划"><a href="#Algorithm1-动态规划" class="headerlink" title="Algorithm1: 动态规划"></a>Algorithm1: 动态规划</h5><p>设从u到v的path中有k条边，设在这个path中v的前一点是x，那么这个path中从u到x则需经过k-1条边。以此细化问题。<br><strong>设δ<sub>k</sub>(u,v)为一条从u到v的path，且path中最多含k条边，且path的cost最小。</strong><br>note：最多k条边不一定要使用k条边，也有可能从u到v不能使用k条边到达。</p>
<h6 id="边界条件"><a href="#边界条件：" class="headerlink" title="边界条件："></a>边界条件：</h6><p>1.因为path中最多有n-1条边，所以必然有δ(u, v) = δ<sub>n−1</sub>(u, v)。<br>2.δ<sub>0</sub>(u,v) = (u == v)? 0 : ∞。 </p>
<h6 id="递归公式"><a href="#递归公式：" class="headerlink" title="递归公式："></a>递归公式：</h6><p>设所有点是x<sub>i</sub>，那么δ<sub>k+1</sub>(u,v) = 求i使得δ<sub>k</sub>(u,x<sub>i</sub>) + w(x<sub>i</sub>,v)最小。</p>
<h6 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> num &#123;</div><div class="line">  boolean isInfinity;</div><div class="line">  <span class="keyword">double</span> value;</div><div class="line">  num(<span class="keyword">double</span> value, <span class="keyword">bool</span> isInfinity) &#123;</div><div class="line">    <span class="keyword">this</span>-&gt;value = value;</div><div class="line">    <span class="keyword">this</span>-&gt;isInfinity = isInfinity;</div><div class="line">  &#125;</div><div class="line">  num <span class="keyword">operator</span> + (<span class="keyword">const</span> num other) &#123;</div><div class="line">    <span class="keyword">if</span> (isInfinity || other.isInfinity) &#123;</div><div class="line">      <span class="keyword">return</span> infinity;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> num(value + other.value, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> num other) &#123;</div><div class="line">    <span class="keyword">if</span> (other.isInfinity) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (other.isInfinity) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> value &gt; other.value;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> num infinity = num(<span class="number">0</span>, <span class="literal">true</span>);<span class="comment">// 0 is an arbitrary number</span></div><div class="line"></div><div class="line">num w[all_vectex.size()][all_vectex.size()];</div><div class="line">num sp[n][all_vectex.size()][all_vectex.size()]; <span class="comment">// store the shortest path result</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u : all_vectex) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : all_vectex) &#123;</div><div class="line">    <span class="keyword">if</span> (u == v) &#123;</div><div class="line">      sp[<span class="number">0</span>][u][v] = num(<span class="number">0</span>, <span class="literal">false</span>); <span class="comment">// 0</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      sp[<span class="number">0</span>][u][v] = infinity</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; w[u][v];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">1</span>) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u : all_vectex) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : all_vectex) &#123;</div><div class="line">      <span class="comment">// below is to calculate sp[k][u][v]</span></div><div class="line">      num temp = infinity;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x : all_vectex) &#123;</div><div class="line">        <span class="keyword">if</span> (temp &gt; sp[k][u][x] + w[x][v]) &#123;</div><div class="line">          temp = sp[k][u][x] + w[x][v];</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      sp[k + <span class="number">1</span>][u][v] = temp;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// return δ&lt;sub&gt;n−1&lt;/sub&gt;(u,v) = sp[n-1][u][v] for all u and v</span></div></pre></td></tr></table></figure>
<h6 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>为O(n<sup>4</sup>)</p>
<h5 id="algorithm2-floyd-warshalls-algorithm"><a href="#Algorithm2-Floyd-Warshall’s-Algorithm" class="headerlink" title="Algorithm2: Floyd-Warshall’s Algorithm"></a>Algorithm2: Floyd-Warshall’s Algorithm</h5><p>设每个点的序号为1~n。<br>定义d<sup>k</sup><sub>ij</sub>代表从i到j的shortest path且path中的所有中间点(intermediate vertices)的序号都属于[1,k]。若k为0，表示[1,k]为空，则d<sup>k</sup><sub>ij</sub>表示从i直接到达j，没有任何中间点。<br>设d<sup>k</sup><sub>ij</sub>只能从d<sup>k-1</sup><sub>ab</sub>得出(a、b为某值)，以此将问题简化。<br>(1)当path中没有k，d<sup>k</sup><sub>ij</sub>的值可能 = d<sup>k-1</sup><sub>ij</sub>，即k的加入并不能使path更短。<br>(2)也可能path中含有k：<br>这时k只能在path中出现一次，所以除k外，所有中间点都在[1,k-1]中。<br><img src="/2017/04/24/图论-一/Floyd-Warshall1.png" alt="Floyd-Warshall1.png" title=""><br>将path从k点切开两段，这两段的所有中间点都在[1,k-1]中。<br>d<sup>k</sup><sub>ij</sub> = d<sup>k-1</sup><sub>ik</sub> + d<sup>k-1</sup><sub>kj</sub>。</p>
<h6 id="递归公式"><a href="#递归公式：-1" class="headerlink" title="递归公式："></a>递归公式：</h6><p>d<sup>k</sup><sub>ij</sub> = min{d<sup>k-1</sup><sub>ij</sub>, d<sup>k-1</sup><sub>ik</sub> + d<sup>k-1</sup><sub>kj</sub>}</p>
<h6 id="边界条件"><a href="#边界条件：-1" class="headerlink" title="边界条件："></a>边界条件：</h6><p>d<sup>0</sup><sub>ij</sub> = w(i,j)<br>最后需要求出d<sup>n</sup><sub>ij</sub> for all i,j。</p>
<h6 id="时间复杂度"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h6><p>对每个k，都要遍历所有的i和j，为O(n<sup>3</sup>)。</p>
<h6 id="输出路径"><a href="#输出路径：" class="headerlink" title="输出路径："></a>输出路径：</h6><p>当我们要知道一个点在不在从i到j的shortest path中时，定义bool值p<sup>k</sup><sub>ij</sub>来表示k是否在从i到j的shortest path中。<br>p<sup>k</sup><sub>ij</sub> = (d<sup>k</sup><sub>ij</sub> == d<sup>k-1</sup><sub>ik</sub> + d<sup>k-1</sup><sub>kj</sub>)? true : false<br>当我们要输出路径时：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(i,j,k)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (p[k][i][j]) &#123;</div><div class="line">    path(i,k,k<span class="number">-1</span>);</div><div class="line">    output k;</div><div class="line">    path(k,j,k<span class="number">-1</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    path(i,j,k<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/24/图论-一/" data-id="cj4ob7fw5000r1me9hpbjtenn" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BFS/">BFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFS/">DFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dijkstra/">Dijkstra</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MST/">MST</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/graph/">graph</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/05/04/图论-二/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          图论(二)Maximum Flow
        
      </div>
    </a>
  
  
    <a href="/2017/04/19/数据库索引/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">数据库索引</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Network/">Computer Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataBase/">DataBase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MST/">MST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maximum-Flow/">Maximum Flow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Set/">Set</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bitwise/">bitwise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graph/">graph</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/Collection/" style="font-size: 10px;">Collection</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/MST/" style="font-size: 10px;">MST</a> <a href="/tags/Maximum-Flow/" style="font-size: 10px;">Maximum Flow</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/bitwise/" style="font-size: 10px;">bitwise</a> <a href="/tags/graph/" style="font-size: 10px;">graph</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/04/图论-二/">图论(二)Maximum Flow</a>
          </li>
        
          <li>
            <a href="/2017/04/24/图论-一/">图论(一):BFS,DFS,MST,Dijkstra</a>
          </li>
        
          <li>
            <a href="/2017/04/19/数据库索引/">数据库索引</a>
          </li>
        
          <li>
            <a href="/2017/04/11/计算机网络协议/">计算机网络协议</a>
          </li>
        
          <li>
            <a href="/2017/04/08/c-虚函数/">c++虚函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Ziliang, Ken, Mo<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>