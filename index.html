<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mozi&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="study notes of programming">
<meta property="og:type" content="website">
<meta property="og:title" content="Mozi's Blog">
<meta property="og:url" content="https://mozi030.github.io/index.html">
<meta property="og:site_name" content="Mozi's Blog">
<meta property="og:description" content="study notes of programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mozi's Blog">
<meta name="twitter:description" content="study notes of programming">
  
    <link rel="alternate" href="/atom.xml" title="Mozi&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mozi&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mozi030.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-图论-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/04/图论-二/" class="article-date">
  <time datetime="2017-05-04T03:14:40.000Z" itemprop="datePublished">2017-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/04/图论-二/">图论(二)Maximum Flow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最大流问题中最典型的问题原型是：<br>你有一堆货物需要从出发点(sourse, s)运输到目的地(sink, t)，你可以在运输网络中(有向图，direct graph, network)沿很多不同的渠道(edge in graph)运输，但每一种渠道都有最大的运输量限制(each each has its capacity)。最终需要求出你最多可以运输多少货物到目的地(get the maximum flow)。</p>
<h5 id="concept"><a href="#concept" class="headerlink" title="concept"></a>concept</h5><p>每一条边edge(u,v)都有它对应的固定容量(capacity)，用c(u,v)表示，指在这条路上运输量的上限。而实际上运输的量就是流(flow)，用f(u,v)表示。0 &lt;= f(u,v) &lt;= c(u,v)。<br>规定<br>(1)f(u,u) = 0。<br>(2)就算edge(u,v)不存在，f(u,v)也存在，且可以是负数。这是为了方便后面的计算。<br>(3)用Σ<sub>v</sub>f(u,v)表示所有从u流出的流的总和。除了s和t，所有点u都满足Σ<sub>v</sub>f(u,v) = 0，即所有货物都不会在所有中继点停留，所有点的流入和流出量是一样的。<br>(4)从s流出的量和向t流入的量是一样的。<br>(5)f(u,v) = -f(v,u)，即：u发送x单位的货物到v，等价于u收到v发过来的-x单位的货物。<br>(6)表示：<br><img src="concept1.png" width="400" height="250" alt="example of flow"><br>对于每条边上的数字，/左边的是这条边的flow，/右边是capacity。如果只有一个数字，表示flow为0，数字为capacity。</p>
<h3 id="ford-fulkersons-algorithm"><a href="#Ford-Fulkerson’s-algorithm" class="headerlink" title="Ford-Fulkerson’s algorithm"></a>Ford-Fulkerson’s algorithm</h3><p>1.先令所有的flow(u,v) = 0。<br>2.不断地找从s到t的一个path(augment path)来使某些flow能增加，直到不能再增加为止。<br>最终找到的流就是maximum flow。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/05/04/图论-二/" data-id="cj4ob7fw9000u1me95fkq07td" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Maximum-Flow/">Maximum Flow</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-图论-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/24/图论-一/" class="article-date">
  <time datetime="2017-04-24T15:36:29.000Z" itemprop="datePublished">2017-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/24/图论-一/">图论(一):BFS,DFS,MST,Dijkstra</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文归纳图论的知识点。</p>
<p>图一般用G = (V, E)表示。连接顶点u和v的边用{u, v}表示。<br>连通图：图中任意两点都连通，即存在路径以它们为始终点。<br>有向图：图中每个边都有方向，无向图相当于是每条边都有正反两个方向的有向图。<br>环：一条路径的起止点事一样的。<br>无环图(acycle)：图中没有环</p>
<h4 id="图的邻接链表"><a href="#图的邻接链表" class="headerlink" title="图的邻接链表"></a>图的邻接链表</h4><img src="/2017/04/24/图论-一/basic1.png" alt="basic1.png" title="">
<p>为每个顶点链接上它所有相连的顶点。</p>
<h3 id="宽度优先搜索bfs"><a href="#宽度优先搜索-BFS" class="headerlink" title="宽度优先搜索(BFS)"></a>宽度优先搜索(BFS)</h3><p>从一个顶点b开始等深度地遍历所有连通的顶点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">queue</span>&lt;Node&gt;q;</div><div class="line">q.push(b);</div><div class="line"><span class="keyword">while</span> (!q.empty()) &#123;</div><div class="line">  Node cur_node = q.front();</div><div class="line">  q.pop();</div><div class="line">  <span class="comment">// do something with cur_node</span></div><div class="line">  <span class="keyword">for</span> (Node next : cur_node.all_next()) &#123;</div><div class="line">    <span class="keyword">if</span> (uncheck(next)) &#123;</div><div class="line">      q.push(next);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若不连通的顶点也要遍历的话，在每次遇到q为empty的时候都检查还有没有顶点是unchecked，若有则push进q再遍历，直到所有顶点都checked。<br>每个顶点都会插入到q一次，并从q中删除一次；每条边都会被遍历两次（分别从两个顶点，若在有向图中则只有一次）。时间复杂度是O(V + E)。</p>
<h4 id="bfs-tree"><a href="#BFS-Tree" class="headerlink" title="BFS Tree"></a>BFS Tree</h4><img src="/2017/04/24/图论-一/bfs1.png" alt="bfs1.png" title="">
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>(1)找图的连通部分。<br>(2)找点v1到点v2之间的所有路径。（记录每个路径走过的点，不走重复点）。<br>(3)找点v1到点v2之间的最短路径。（第一个找到的路径即为最短。）</p>
<h3 id="深度优先搜索dfs"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p>沿一个路径不断往深遍历，直到尽头（没有unchecked的点），再逐步回溯。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> prev_node[v_num];</div><div class="line"><span class="keyword">bool</span> checked[v_num];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">memset</span>(prev_node, <span class="number">-1</span>, <span class="keyword">sizeof</span>(prev_node));</div><div class="line">  <span class="built_in">memset</span>(checked, <span class="literal">false</span>, <span class="keyword">sizeof</span>(checked));</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_num; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (!checked[i]) &#123;</div><div class="line">      DFS_visit(i);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_visit</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">  checked[index] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> next : v[index].all_next()) &#123;</div><div class="line">    <span class="keyword">if</span> (!checked[next]) &#123;</div><div class="line">      prev[next] = index;</div><div class="line">      DFS_visit(index);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DFS是基于stack实现的，上例用函数栈来代替stack，当然也可以直接用stack来实现。<br>若stack为empty，push下一个unchecked的点，若不为empty，去栈顶元素，并push这个元素的所有unchecked的next。<br>若要记录深度depth或step，要不在stack中存储的Node结构体中加入成员，要不在函数内传参，并在DFS_visit前后为depth++，和–。</p>
<p>每个顶点将被遍历一次，每条边被遍历一次。所以时间复杂度是O(V + E)。</p>
<h4 id="dfs-tree"><a href="#DFS-Tree" class="headerlink" title="DFS Tree"></a>DFS Tree</h4><img src="/2017/04/24/图论-一/dfs1.png" alt="dfs1.png" title="">
<h3 id="关节点articulation-point"><a href="#关节点-Articulation-Point" class="headerlink" title="关节点(Articulation Point)"></a>关节点(Articulation Point)</h3><p>在无向连通图中，一个点是关节点，iff删除这个点后原图被分为若干个连通图。<br>1.The leaves of a DFS tree are not articulartion points.<br>2.The root is not a articulation point iff it has at most one child.<br>3.Vertex d is not an articulation point iff there are back edges that connect every subtree rooted at a child of d to an ancestor of d.<br><img src="/2017/04/24/图论-一/Articulation_Point1.png" alt="Articulation_Point1.png" title=""><br>时间复杂度为O(n<sup>2</sup>)。</p>
<h3 id="生成树spanning-tree"><a href="#生成树-spanning-tree" class="headerlink" title="生成树(spanning tree)"></a>生成树(spanning tree)</h3><p>G的生成树是一个G的无环连通子图，且包含G的所有点V。<br>一颗生成树的权重是生成树中所有边的权重之和。<br>G中存在n个顶点的话，那么生成树中就有(n - 1)条边。</p>
<h4 id="最小生成树minimal-spanning-treemst"><a href="#最小生成树-minimal-spanning-tree-MST" class="headerlink" title="最小生成树(minimal spanning tree,MST)"></a>最小生成树(minimal spanning tree,MST)</h4><p>是G的权重最小的生成树。</p>
<h5 id="kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><p>设G施一个无向图，<br>(1)将图中所有边按权重的升序排序。<br>(2)不断遍历这些排好序的边，并维护一个forest F，且保证F是G的子图。<br>(3)F的初始状态是V，即只含G的所有顶点。<br>(4)不断选取边加入到F中，并保证每次加入都不会生成环，否则跳过这条边。<br>(5)直到F中插入了(n - 1)条边。<br>要保证无环，则要为F中所有连通部分分别取一个id，而同一连通部分中所有顶点的id是相同的。每个顶点的起始id是该顶点的id，若加入某条边时检查两个顶点的id是否一样，若不一样则另顶点较少的连通部分的id全部置为顶点较多的部分的id。</p>
<h6 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h6><p>用数学归纳法：证每次插入边后形成的forest F都是G的MST的子图。<br>(1)初始状态只含所有顶点，明显是MST的子图。<br>(2)若已知当前的F是MST的子图，要插入的下一条边为e，根据Kruskal算法，e将会把当前F中的两棵不连通的树T1，T2连通。现用反证法证插入e后，也会生成MST的子图。<br>(3)若e不属于MST，则{e} ∪ MST后会导致MST成环C，因MST是所有顶点连通的。C中包含e，T1和T2的一部分，以及在e之后将会插入的一些边e’，因T1，T2并不连通。因为e比e’中所有边的权重都小，所以将e代替e’中任意一边都能生成更小的MST，所以矛盾。</p>
<p>时间复杂度：<br>排序需要mlog(m) = mlog(n)<br>当一个顶点的id要变化时，其所在连通部分的大小至少要double。所以一个顶点的id最多变化log<sub>2</sub>n次，所以所有顶点id变化的时间复杂度是nlog(n)。<br>总时间复杂度是mlog(n) + nlog(n) = mlog(n)。</p>
<h3 id="shortest-path"><a href="#Shortest-Path" class="headerlink" title="Shortest Path"></a>Shortest Path</h3><h4 id="dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>在带权图中找一条weight最小的path，但这要求所有weight非零。设起点为s。</p>
<h5 id="shortest-path-tree"><a href="#Shortest-Path-Tree" class="headerlink" title="Shortest Path Tree"></a>Shortest Path Tree</h5><p>将从s到任意点的shortest path都找出来，并求这些path的union。若有两个path分别以边e和边e’经过顶点u，那么我们将删除e或e’，来使union中没有环。<br><img src="/2017/04/24/图论-一/dijkstra1.png" alt="dijkstra1.png" title=""><br>有了shortest path tree后，从s到任意点的shortest path就是在tree中s到任意点的path。<br>注意若图是有向的，那么shortest path tree只能代表从s到任意点的shortest path，而不代表从任意点到s的path。要求从点a到其他点的shortest path，那么就要从点a建shortest path tree。<br>Dijkstra就是用来生成shortest path tree的。</p>
<h5 id="algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h5><p>维护一个数组D[v]来表示从s到v的最小cost(s ≠ v)。<br>维护数组prev[v]来表示v在shortest path中的前一个顶点。<br><img src="/2017/04/24/图论-一/dijkstra2.png" alt="dijkstra2.png" title=""><br>用w(u,v)来表示边(u,v)的权重，若不存在边(u,v)则w(u,v) = +∞。<br>Q是包含所有顶点的set。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> i &lt; node_num; i++) &#123;</div><div class="line">  D[i] = +∞;</div><div class="line">  prev[i] = null;</div><div class="line">  Q.push(i);</div><div class="line">&#125;</div><div class="line">D[s] = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (!Q.empty())) &#123;</div><div class="line">  index = extract_min_D_from_Q(); <span class="comment">// get the min D[index] from Q, and then remove</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> next : Q) &#123;</div><div class="line">    <span class="keyword">if</span> (D[next] &gt; D[index] + w(index, next)) &#123;</div><div class="line">      D[next] = D[index] + w(index, next);</div><div class="line">      prev[next] = index;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>普通实现的时间复杂度是O(n<sup>2</sup>)<br>优化方案：用平衡树来存储Q，Q的比较函数设为用D[i]的大小来比较。那么插入，删除，查询都只需要O(log(n))。更新D[i]相当于先从Q中删除D[i]再插入新的D[i]，也是需要O(log(n))。<br>建树和n次查询、删除需要nlog(n)时间，在每一条边上都可能更新D[i]一次，所以更新的时间为mlog(n)。<br>总时间复杂度是nlog(n) + mlog(n) = mlog(n)。当m小于n<sup>2</sup>/log(n)时，优化方案会比较快。</p>
<h4 id="任意点到任一点的shortest-pathall-pairs-of-shortest-path"><a href="#任意点到任一点的shortest-path-All-Pairs-of-Shortest-Path" class="headerlink" title="任意点到任一点的shortest path(All Pairs of Shortest Path)"></a>任意点到任一点的shortest path(All Pairs of Shortest Path)</h4><p>设G为带权有向图，= {V, E}。<br>对任意边(u, v)， 求δ(u, v) = 从u到v的shortest path。<br>若所有weight都是非负的，则使用Dijkstra可得复杂度为O(n<sup>3</sup>)或O(n<sup>2</sup>log(n) + mnlog(n))。<br>但是当存在负weight的时候则不能使用Dijkstra了。</p>
<p>首先，不存在负环(negative cycle)，因不断遍历负环就可以让weight无限小，就没有shortest path一说了。所以shortest path是指weight最小且不经过负环的path，或者说weight最小且不经过重复点的path。也因此，path中最多有n-1条边。</p>
<h5 id="algorithm1-动态规划"><a href="#Algorithm1-动态规划" class="headerlink" title="Algorithm1: 动态规划"></a>Algorithm1: 动态规划</h5><p>设从u到v的path中有k条边，设在这个path中v的前一点是x，那么这个path中从u到x则需经过k-1条边。以此细化问题。<br><strong>设δ<sub>k</sub>(u,v)为一条从u到v的path，且path中最多含k条边，且path的cost最小。</strong><br>note：最多k条边不一定要使用k条边，也有可能从u到v不能使用k条边到达。</p>
<h6 id="边界条件"><a href="#边界条件：" class="headerlink" title="边界条件："></a>边界条件：</h6><p>1.因为path中最多有n-1条边，所以必然有δ(u, v) = δ<sub>n−1</sub>(u, v)。<br>2.δ<sub>0</sub>(u,v) = (u == v)? 0 : ∞。 </p>
<h6 id="递归公式"><a href="#递归公式：" class="headerlink" title="递归公式："></a>递归公式：</h6><p>设所有点是x<sub>i</sub>，那么δ<sub>k+1</sub>(u,v) = 求i使得δ<sub>k</sub>(u,x<sub>i</sub>) + w(x<sub>i</sub>,v)最小。</p>
<h6 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> num &#123;</div><div class="line">  boolean isInfinity;</div><div class="line">  <span class="keyword">double</span> value;</div><div class="line">  num(<span class="keyword">double</span> value, <span class="keyword">bool</span> isInfinity) &#123;</div><div class="line">    <span class="keyword">this</span>-&gt;value = value;</div><div class="line">    <span class="keyword">this</span>-&gt;isInfinity = isInfinity;</div><div class="line">  &#125;</div><div class="line">  num <span class="keyword">operator</span> + (<span class="keyword">const</span> num other) &#123;</div><div class="line">    <span class="keyword">if</span> (isInfinity || other.isInfinity) &#123;</div><div class="line">      <span class="keyword">return</span> infinity;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> num(value + other.value, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> num other) &#123;</div><div class="line">    <span class="keyword">if</span> (other.isInfinity) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (other.isInfinity) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> value &gt; other.value;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> num infinity = num(<span class="number">0</span>, <span class="literal">true</span>);<span class="comment">// 0 is an arbitrary number</span></div><div class="line"></div><div class="line">num w[all_vectex.size()][all_vectex.size()];</div><div class="line">num sp[n][all_vectex.size()][all_vectex.size()]; <span class="comment">// store the shortest path result</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u : all_vectex) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : all_vectex) &#123;</div><div class="line">    <span class="keyword">if</span> (u == v) &#123;</div><div class="line">      sp[<span class="number">0</span>][u][v] = num(<span class="number">0</span>, <span class="literal">false</span>); <span class="comment">// 0</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      sp[<span class="number">0</span>][u][v] = infinity</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; w[u][v];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">1</span>) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u : all_vectex) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : all_vectex) &#123;</div><div class="line">      <span class="comment">// below is to calculate sp[k][u][v]</span></div><div class="line">      num temp = infinity;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x : all_vectex) &#123;</div><div class="line">        <span class="keyword">if</span> (temp &gt; sp[k][u][x] + w[x][v]) &#123;</div><div class="line">          temp = sp[k][u][x] + w[x][v];</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      sp[k + <span class="number">1</span>][u][v] = temp;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// return δ&lt;sub&gt;n−1&lt;/sub&gt;(u,v) = sp[n-1][u][v] for all u and v</span></div></pre></td></tr></table></figure>
<h6 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>为O(n<sup>4</sup>)</p>
<h5 id="algorithm2-floyd-warshalls-algorithm"><a href="#Algorithm2-Floyd-Warshall’s-Algorithm" class="headerlink" title="Algorithm2: Floyd-Warshall’s Algorithm"></a>Algorithm2: Floyd-Warshall’s Algorithm</h5><p>设每个点的序号为1~n。<br>定义d<sup>k</sup><sub>ij</sub>代表从i到j的shortest path且path中的所有中间点(intermediate vertices)的序号都属于[1,k]。若k为0，表示[1,k]为空，则d<sup>k</sup><sub>ij</sub>表示从i直接到达j，没有任何中间点。<br>设d<sup>k</sup><sub>ij</sub>只能从d<sup>k-1</sup><sub>ab</sub>得出(a、b为某值)，以此将问题简化。<br>(1)当path中没有k，d<sup>k</sup><sub>ij</sub>的值可能 = d<sup>k-1</sup><sub>ij</sub>，即k的加入并不能使path更短。<br>(2)也可能path中含有k：<br>这时k只能在path中出现一次，所以除k外，所有中间点都在[1,k-1]中。<br><img src="/2017/04/24/图论-一/Floyd-Warshall1.png" alt="Floyd-Warshall1.png" title=""><br>将path从k点切开两段，这两段的所有中间点都在[1,k-1]中。<br>d<sup>k</sup><sub>ij</sub> = d<sup>k-1</sup><sub>ik</sub> + d<sup>k-1</sup><sub>kj</sub>。</p>
<h6 id="递归公式"><a href="#递归公式：-1" class="headerlink" title="递归公式："></a>递归公式：</h6><p>d<sup>k</sup><sub>ij</sub> = min{d<sup>k-1</sup><sub>ij</sub>, d<sup>k-1</sup><sub>ik</sub> + d<sup>k-1</sup><sub>kj</sub>}</p>
<h6 id="边界条件"><a href="#边界条件：-1" class="headerlink" title="边界条件："></a>边界条件：</h6><p>d<sup>0</sup><sub>ij</sub> = w(i,j)<br>最后需要求出d<sup>n</sup><sub>ij</sub> for all i,j。</p>
<h6 id="时间复杂度"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h6><p>对每个k，都要遍历所有的i和j，为O(n<sup>3</sup>)。</p>
<h6 id="输出路径"><a href="#输出路径：" class="headerlink" title="输出路径："></a>输出路径：</h6><p>当我们要知道一个点在不在从i到j的shortest path中时，定义bool值p<sup>k</sup><sub>ij</sub>来表示k是否在从i到j的shortest path中。<br>p<sup>k</sup><sub>ij</sub> = (d<sup>k</sup><sub>ij</sub> == d<sup>k-1</sup><sub>ik</sub> + d<sup>k-1</sup><sub>kj</sub>)? true : false<br>当我们要输出路径时：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(i,j,k)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (p[k][i][j]) &#123;</div><div class="line">    path(i,k,k<span class="number">-1</span>);</div><div class="line">    output k;</div><div class="line">    path(k,j,k<span class="number">-1</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    path(i,j,k<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/24/图论-一/" data-id="cj4ob7fw5000r1me9hpbjtenn" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BFS/">BFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFS/">DFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dijkstra/">Dijkstra</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MST/">MST</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/graph/">graph</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/数据库索引/" class="article-date">
  <time datetime="2017-04-19T02:27:24.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DataBase/">DataBase</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/数据库索引/">数据库索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文归纳数据库索引的知识点</p>
<p>如果我们希望寻找ID为123456的人，且数据库有10,000,000条数据，每一个储存页只能放10条数据，即我们有1,000,000个数据页。下面评估各种查询数据方法的用时，以页为单位：<br>1.如果这些数据随机存放，则我们需要查询1,000,000页；<br>2.如果这些数据已被排序，则查询需要log<sub>2</sub>10<sup>6</sup> = 20页；<br>3.更快的方法是使用index entry：</p>
<h3 id="一-index-entry"><a href="#一、index-entry" class="headerlink" title="一、index entry"></a>一、index entry</h3><p>包含一个search key和能找到这个search key的page ID，e.g.,<123456,456>。<br>我们不必为每一条数据建一个index entry，只需用index entry记录每页中第一个数据，即每页对应一个index entry，即1,000,000个index entry。若某页的index entry为<10100,400>，下一页的index entry为<10200,401>，则search key为10100~10199的数据都在第400页中。<br>假设一页可以存放100个index entry，则需要10,000页来存放所有index entry。而且这些index entry也要经过search key排序。因此search key为1~100的index entry在第1页，9,999,900~10,000,000的index entry在第10,000页。<br><img src="/2017/04/19/数据库索引/index1.png" alt="index1.png" title=""><br>若我们需要查询search key为k的数据，则从第一层index entry搜索需要查询log<sub>2</sub>10<sup>4</sup> = 14页，搜索后通过选中的index entry的page ID找到存放该数据的数据页，则从该页中可找到search key为k的数据。一共需要查询14 + 1 = 15页。<br>若在继续建立二级索引、三级索引：<br><img src="/2017/04/19/数据库索引/index2.png" alt="index2.png" title=""><br>一级索引需要10,000页，二级需要100页，三级只有1页，查询一个数据只需查询4页即可。</10200,401></10100,400></123456,456></p>
<h4 id="ordered-index有序索引also-called-tree"><a href="#ordered-index有序索引（also-called-tree）" class="headerlink" title="ordered index有序索引（also called tree）"></a>ordered index有序索引（also called tree）</h4><p>所有的index entry都是排好序的，因此有利于寻找同值数据或范围搜索。</p>
<h4 id="fanout扇出"><a href="#fanout扇出" class="headerlink" title="fanout扇出"></a>fanout扇出</h4><p>每个index page的children数量。</p>
<h4 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h4><p>height = log<sub>fanout</sub>(#index entries)。</p>
<h4 id="primary-indexclustering-index聚类索引"><a href="#primary-index-clustering-index聚类索引" class="headerlink" title="primary index(clustering index聚类索引)"></a>primary index(clustering index聚类索引)</h4><p>数据是按照索引的search key排序的。</p>
<h5 id="isamindexed-sequential-access-method"><a href="#ISAM-indexed-sequential-access-method" class="headerlink" title="ISAM(indexed sequential access method)"></a>ISAM(indexed sequential access method)</h5><p>使用primary index处理index-sequential file</p>
<h4 id="secondary-indexnon-clustering-index非聚类索引"><a href="#secondary-index-non-clustering-index非聚类索引" class="headerlink" title="secondary index(non-clustering index非聚类索引)"></a>secondary index(non-clustering index非聚类索引)</h4><p>数据不是按照索引的search key排序的<br><img src="/2017/04/19/数据库索引/index3.png" alt="index3.png" title=""></p>
<h4 id="sparse-index"><a href="#sparse-index" class="headerlink" title="sparse index"></a>sparse index</h4><p>只对部分数据做索引，如前面的例子中，只对每一个数据页的第一个数据作索引。<br>1.只适用于primary index。<br>2.对于插入和删除，工作量较少。</p>
<h4 id="dense-index"><a href="#dense-index" class="headerlink" title="dense index"></a>dense index</h4><p>对每个数据都有对应的index entry。<br>1.secondary index必须是dense。<br>e.g.,如果在上例中我们想用name来找数据而不是ID，我们需要另外建search key为name的索引。<br>由于数据已经按ID来排序，所以只能使用secondary dense index，所以将会有10,000,000个index entry，需要搜索log<sub>100</sub>(107)页<br>notes: 若只找一个数据，secondary dense index与primary index的用时差不多，但是当查询多个数据（如范围所搜）时，secondary index就可能比primary慢得多。<br>2.若存在很多人同名的情况：(primary index中不会有任何问题)<br>2.1可将index entry格式改为<search key,="" pageid1,="" pageid2,...=""><br>2.2或<search key,="" pageid1="">, <search key,="" pageid2="">, <search key,="" pageid3="">,…（index entry是排好序的。）<br>2.3最常用的方法：在数据页和index tree中间加一层bucket层。查询时，用name定位到一个bucket，bucket中包含所有同名数据的page ID。<br><img src="/2017/04/19/数据库索引/index4.png" alt="index4.png" title=""></search></search></search></search></p>
<h3 id="二-hash-index"><a href="#二、Hash-Index" class="headerlink" title="二、Hash Index"></a>二、Hash Index</h3><h4 id="静态hashstatic-hash"><a href="#静态hash-static-hash" class="headerlink" title="静态hash(static hash)"></a>静态hash(static hash)</h4><p>1.将search key和对应的page ID(pointers)放入hash table中。<br>2.是一种secondary index。<br>3.我们希望数据不会增删太多（静态数据库static database），不然维护需要成本。<br><img src="/2017/04/19/数据库索引/index5.png" alt="index5.png" title=""><br>4.理想的hash table是分布均匀的，若所有的search key都map到同一个bucket，会大大增加搜索时间。hash function的例子：将search key转为2进制，取倒数两位作为hash code。<br>5.bucket溢出：原因可能是bucket太少，hash function不能均匀分配数据到各个bucket。解决方法为链表法，但是就会提高搜索时间。<br>6.十分有利于找同search key的数据，但不支持范围查找，多值查找。<br>7.当数据增删，可能需要增删bucket，hash function和每一个bucket的内容都要改动。</p>
<h4 id="动态hashdynamic-hash-extendible-hash"><a href="#动态hash-dynamic-hash-extendible-hash" class="headerlink" title="动态hash(dynamic hash, extendible hash)"></a>动态hash(dynamic hash, extendible hash)</h4><p>static hash的缺点：<br>1.当数据库变大，overflow会增加，性能变差。<br>2.需周期性重构hash结构。<br>因此我们需要动态改变#bucket。<br>当一个bucket(primary page)满了，我们简单地double bucket的数量，代价会很昂贵，因为所有bucket都要重新读写。<br>但若我们使用目录(directory)来储存一组指向bucket的pointer，然后只double目录，并只分裂和重构那些overflow的bucket，这样做会比较cheap，因为我们只double了目录（比bucket小很多），和需要修改hash function。</p>
<h5 id="目录的global-depth"><a href="#目录的global-depth" class="headerlink" title="目录的global depth"></a>目录的global depth</h5><p>分配数据到bucket所需的最大#bit，一般为log<sub>2</sub>(#bucket)。</p>
<h5 id="bucket的local-depth"><a href="#bucket的local-depth" class="headerlink" title="bucket的local depth"></a>bucket的local depth</h5><p>判断一个数据是否属于自己bucket所需的#bit。若overflow的话，就要分裂bucket，并把local depth++。</p>
<h5 id="如何插入数据"><a href="#如何插入数据" class="headerlink" title="如何插入数据"></a>如何插入数据</h5><img src="/2017/04/19/数据库索引/index15.png" alt="index15.png" title="">
<p>若插入一个新的数据时，首先计算其hash code，从目录中获取对应的pointer，进入到对应的bucket，插入到bucket中，若bucket没有overflow，则完成插入；若有overflow，则分裂、重构这个bucket，（若A分裂为A和A2，则A2叫做A的split image）并令新的两个bucket的local depth++。若此时local depth &gt; global depth，那么令目录double，且global depth也++，目录double后，分裂出来的两个新bucket在目录中将有不同的pointer，但是未分裂的bucket将会被目录两个pointer所指向，因其还未overflow，无需分裂。若bucket分裂且local depth++后发现local depth = global depth，证明目录之前已被double过，则无需再double，只需将被原来指向未分裂时的bucket的两个pointer分别指向新的两个bucket即可。</p>
<p>但是还有潜在的问题：overflow可能在目录double后并不会消失，即bucket中的数据不能被新的hash function分离。</p>
<h5 id="如何删除数据"><a href="#如何删除数据" class="headerlink" title="如何删除数据"></a>如何删除数据</h5><p>若删除数据后某些bucket为空，则合并这个bucket和它的split image，并把原来指向这两个bucket的pointer都指向合并后的pointer。若目录中每一个pointer都和它成对的pointer（指向split image的pointer）指向同一个bucket，那么这个目录就可以减半了，把global depth–。</p>
<h5 id="线性hashlinear-hashlh"><a href="#线性hash-Linear-hash-LH" class="headerlink" title="线性hash(Linear hash,LH)"></a>线性hash(Linear hash,LH)</h5><p>是另一种动态hash，且是可扩展的。<br>LH不使用目录，且能处理overflow的问题，还能去重。<br>concept：定义一组hash function：h0,h1,h2,…其中hi = h(key) mod(2<sup>i</sup>N)，N = #bucket为2的次方。令N = 2<sup>d0</sup>，hi的意义为获取key的后di bit数字，di = d0 + i。所以hi+1比hi的hash code多了一倍，相当于做了目录double。</p>
<p>在LH中，分裂过程是按“轮”(round)算的，Level代表当前在进行第几轮分裂，设第r轮(Level = r)有Nr个bucket需要分裂。每轮中分裂是按bucket顺序分裂的，即第0~i个bucket分裂后，第i+1个bucket才能分裂。设指针Next指向当前需要分裂的bucket，即第0~Next-1个bucket已分裂，Next~Nr个bucket还没分裂。</p>
<h6 id="线性hash查询数据"><a href="#线性hash查询数据" class="headerlink" title="线性hash查询数据"></a>线性hash查询数据</h6><p>若选择要查询数据r，计算h<sub>Level</sub>(r)：若它在[Next,Nr)中，则r在h<sub>Level</sub>(r)对应的bucket中；若在[0,Next-1]中，r在h<sub>Level</sub>(r)或h<sub>Level</sub>(r)+Nr对应的bucket中，需要计算h<sub>Level+1</sub>(r)来确定。</p>
<h6 id="线性hash插入数据"><a href="#线性hash插入数据" class="headerlink" title="线性hash插入数据"></a>线性hash插入数据</h6><p>插入数据时若出现overflow，会采用overflow pages来存储数据。适时移动Next指针(Next++)来分裂bucket。若第Nr-1个bucket分裂后Level++，之后可重新定义Nr和Next的值，进入下一轮。<br><img src="/2017/04/19/数据库索引/index16.png" alt="index16.png" title=""></p>
<h3 id="三-b-tree"><a href="#三、B-Tree" class="headerlink" title="三、B+ Tree"></a>三、B<sup>+</sup> Tree</h3><p>index-sequential file的缺点是：当数据规模增大，性能会下降，需要多次对index file重建。<br>而B<sup>+</sup> Tree的index file只需简单地修改。</p>
<h4 id="concept"><a href="#concept" class="headerlink" title="concept"></a>concept</h4><p>1.B<sup>+</sup> Tree是一颗平行树(balence tree)，根节点到所有叶子节点的路径等长。<br>2.若根节点不是leaf，则至少有2个children；若是leaf，只可能有0~(n-1)个数据。<br>3.除根节点外，所有非leaf节点只可能有n/2~n个pointer，leaf只可能有(n–1)/2~(n–1)个数据。<br>其中n为fanout扇出，是每个节点的最大children数。(pointer会比数据多一个)<br>每个节点的结构如下：<br><img src="/2017/04/19/数据库索引/index6.png" alt="index6.png" title=""><br>4.对于leaf，若pointer Pi右边的值是Ki(1 &lt;= i &lt;= (n-1))，则Pi指向search key同样为Ki的数据或一个包含所有search key为Ki的pointer的bucket。最后一个pointer(Pn)指向其右边的sibling，即按search key排序的下一个sibling，不指向任何数据。<br>5.对于non-leaf节点，P1指向的subtree的所有数据的search key均 &lt; K1，Pi(1 &lt; i &lt; n)的subtree的所有数据的search key均 &lt; Ki且 &gt; Ki-1。</p>
<p>e.g.:<br>primary(clustering) B<sup>+</sup> Tree<br><img src="/2017/04/19/数据库索引/index7.png" alt="index7.png" title=""><br>secondary B<sup>+</sup> Tree<br><img src="/2017/04/19/数据库索引/index8.png" alt="index8.png" title=""><br>primary B<sup>+</sup> Tree on non-candidate key<br><img src="/2017/04/19/数据库索引/index9.png" alt="index9.png" title=""><br><img src="/2017/04/19/数据库索引/index10.png" alt="index10.png" title=""></p>
<h4 id="查询b-tree"><a href="#查询B-Tree" class="headerlink" title="查询B+ Tree"></a>查询B<sup>+</sup> Tree</h4><p>设查询search key为k的数据，每个非leaf节点有m个pointer。<br>1.从root开始，若存在Kj = k，沿Pj+1到下一节点；else if有k &lt; Kj（j为最小的一个），沿Pj到下一节点；else，即k大于所有的在这个节点中的K，则沿Pm到下一节点。<br>2.若下一节点不是leaf，重复第1步。<br>3.当到达leaf时，若存在Kj = k，则沿Pi到达所指向的数据或bucket（同search key）；若不存在，查询失败。<br>查询次数最大为log<sub>n/2</sub>(#search key)。<br>一个节点大概有4KB，fanout一般为100。</p>
<h4 id="向b-tree增加数据"><a href="#向B-Tree增加数据" class="headerlink" title="向B+ Tree增加数据"></a>向B<sup>+</sup> Tree增加数据</h4><p>1.用数据的search key查询树，找到叶子节点L；<br>2.插入：若L有足够的空间，插入成功；若没有足够的空间，插入后将L分裂，把L平均分配成L1和L2，把L2的第一个值<strong>复制</strong>到L的parent，并加上指向L2的pointer。<br>3.由于L的parent也会多了值和pointer，所以递归地运行第2步。不同的是，若非leaf节点分裂，要将分列前中间的值<strong>提取</strong>并上传。出来若root需要分裂，则会增加高度。<br><img src="/2017/04/19/数据库索引/index11.png" alt="index11.png" title=""></p>
<h4 id="在b-tree中删除数据"><a href="#在B-Tree中删除数据" class="headerlink" title="在B+ Tree中删除数据"></a>在B<sup>+</sup> Tree中删除数据</h4><p>1.用数据的search key查询树，找到叶子节点L；<br>2.删除节点：若L至少是半满，删除成功；若少于半满，就要再分配，从右边的sibling中借值；若分配失败，则合并L和右边的sibling。<br>3.如果出现了合并，要把sibling的值和pointer从parent中删除。这种删除可能会向上传递，更可能删除root而减少height。<br><img src="/2017/04/19/数据库索引/index12.png" alt="index12.png" title=""></p>
<h4 id="建b-treebulk-loading"><a href="#建B-Tree：Bulk-Loading" class="headerlink" title="建B+ Tree：Bulk Loading"></a>建B<sup>+</sup> Tree：Bulk Loading</h4><p>若将数据逐个插入B<sup>+</sup> Tree，将会十分慢。<br>Bulk Loading的做法：<br>1.把data按search key排序(使用external sort)<br>2.放置第1个leaf和root<br><img src="/2017/04/19/数据库索引/index13.png" alt="index13.png" title=""><br>3.不断插入，新插入的page会把其第一个data的search key插入到第二层index的最右边，这可能会导致分裂，令树高度增高。<br><img src="/2017/04/19/数据库索引/index14.png" alt="index14.png" title=""></p>
<h3 id="四-sql中的index"><a href="#四、SQL中的index" class="headerlink" title="四、SQL中的index"></a>四、SQL中的index</h3><h4 id="创建index"><a href="#创建index" class="headerlink" title="创建index"></a>创建index</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">index</span> &lt;<span class="keyword">index</span>-<span class="keyword">name</span>&gt; <span class="keyword">on</span> &lt;relation-<span class="keyword">name</span>&gt; (&lt;<span class="keyword">attribute</span> <span class="keyword">list</span>&gt;)</div><div class="line">e.g.</div><div class="line"><span class="keyword">create</span> <span class="keyword">index</span> brance-<span class="keyword">index</span> <span class="keyword">on</span> Branch(branch-<span class="keyword">name</span>)</div><div class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> brance-<span class="keyword">index</span> <span class="keyword">on</span> Branch(branch-<span class="keyword">name</span>)</div></pre></td></tr></table></figure>
<p>unique强制search key为candidate key</p>
<h4 id="删除index"><a href="#删除index" class="headerlink" title="删除index"></a>删除index</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">drop</span> <span class="keyword">index</span> &lt;<span class="keyword">index</span>-<span class="keyword">name</span>&gt;</div><div class="line">e.g.</div><div class="line"><span class="keyword">drop</span> <span class="keyword">index</span> brance-<span class="keyword">index</span></div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/19/数据库索引/" data-id="cj4ob7fwb000x1me9yupn632b" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/11/计算机网络协议/" class="article-date">
  <time datetime="2017-04-11T08:35:47.000Z" itemprop="datePublished">2017-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Computer-Network/">Computer Network</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/11/计算机网络协议/">计算机网络协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文总结计算机网络各种协议的知识点</p>
<p>OSI(Open System Interconnection开放式系统互联)分层(7层)：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>Linux TCP/IP分层(4层)：网络接口层（物理层+数据链路层）、网际层（网络层）、运输层（传输层）、应用层（会话层+表示层+应用层）。<br>五层协议(5层)：物理层、数据链路层、网络层、运输层、应用层。</p>
<p>常见协议有：<br>物理层：RJ45、CLOCK、IEEE802.3 (中继器,集线器)<br>数据链路：PPP、FR、HDLC、VLAN、MAC (网桥,交换机)<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 (路由器)<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS </p>
<p>下面分层介绍：</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>通过媒介传输比特,确定机械及电气规范(比特Bit)</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>将比特组装成帧和点到点的传递(帧Frame)</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>负责数据包从源到宿的传递和网际互连(包PackeT)</p>
<h3 id="ip协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议为用户和远程计算机提供了信息包的传输方法，确保信息包能正确地到达目的机器。</p>
<h3 id="ip地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>A类地址：以0开头，第一个字节范围是0~126：(1.0.0.0 ~ 126.255.255.255)<br>B类地址：以10开头, 第一个字节范围:128~191(128.0.0.0 - 191.255.255.255)<br>C类地址：以110开头, 第一个字节范围:192~223(192.0.0.0 - 223.255.255.255)<br>内网地址：10.0.0.0—10.255.255.255, 172.16.0.0—172.31.255.255, 192.168.0.0—192.168.255.255。<br>网络号：可由IP地址和子网掩码取&amp;得到</p>
<p>IP报文格式:<br><img src="/2017/04/11/计算机网络协议/IP_format.jpg" alt="IP_format.jpg" title=""></p>
<h3 id="arpaddress-resolution-protocol地址解释协议"><a href="#ARP-Address-Resolution-Protocol地址解释协议" class="headerlink" title="ARP(Address Resolution Protocol地址解释协议)"></a>ARP(Address Resolution Protocol地址解释协议)</h3><p>根据IP地址获取MAC地址的一个TCP/IP协议。<br>OSI模型把网络工作分为七层，IP地址在OSI模型的第三层，MAC地址在第二层，彼此不直接打交道。在通过以太网发送IP数据包时，需要先封装第三层（32位IP地址）、第二层（48位MAC地址）的报头，但由于发送时只知道目标IP地址，不知道其MAC地址，又不能跨第二、三层，所以需要使用地址解析协议。使用地址解析协议，可根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息，以保证通信的顺利进行。<br>(1)每个主机都有自己的ARP缓冲区，这个缓冲区有一个ARP列表，用来储存各种IP地址和其对应的MAC地址。<br>(2)当源主机要发送数据时，会从自己的ARP表中从出所需IP地址对应的MAC地址，如果能找到就直接发送。<br>(3)如果没有找到，就广播ARP请求给网络中的所有主机，请求数据包中有源主机IP地址，源主机MAC地址，目的主机的IP地址。当其他主机收到请求后会检查ARP请求数据包中的IP地址是否为自己，不是就直接忽略这个包。之后目的主机收到数据包后，才会处理：从数据包中取出源主机的IP和MAC地址写入到自己的ARP列表中（会覆盖原有的源主机MAC地址），然后将自己的MAC地址写入ARP响应包中，单播给源主机，告诉源主机自己是它想要找的MAC地址。<br>(4)源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表，之后就可以执行(2)的操作。</p>
<h3 id="rarp反向地址转换协议"><a href="#RARP-反向地址转换协议" class="headerlink" title="RARP(反向地址转换协议)"></a>RARP(反向地址转换协议)</h3><h3 id="icmp协议internet-control-message-protocol因特网控制报文协议"><a href="#ICMP协议-Internet-Control-Message-Protocol因特网控制报文协议" class="headerlink" title="ICMP协议(Internet Control Message Protocol因特网控制报文协议)"></a>ICMP协议(Internet Control Message Protocol因特网控制报文协议)</h3><p>ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况，也能确保连线的准确性。<br>(1)是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息，包括报告错误、交换受限控制和状态信息等。<br>(2)控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。<br>(3)当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。ICMP报文在IP帧结构的首部协议类型字段（Protocol 8bit)的值=1<br>(4)但是ICMP唯一的功能是报告问题而不是纠正错误，纠正错误的任务由发送方完成。<br>(5)我们在网络中经常会使用到ICMP协议，比如我们经常使用的用于检查网络通不通的Ping命令（Linux和Windows中均有），这个“Ping”的过程实际上就是ICMP协议工作的过程。还有其他的网络命令如跟踪路由的Tracert命令也是基于ICMP协议的。</p>
<h3 id="tftp协议"><a href="#TFTP协议" class="headerlink" title="TFTP协议"></a>TFTP协议</h3><p>是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>提供端到端的可靠报文传递和错误恢复(段Segment)</p>
<h3 id="tcptransmission-control-protocol传输控制协议"><a href="#TCP-Transmission-Control-Protocol传输控制协议" class="headerlink" title="TCP(Transmission Control Protocol传输控制协议)"></a>TCP(Transmission Control Protocol传输控制协议)</h3><p>TCP建立在IP之上，定义了网络上程序到程序的数据传输格式和规则，提供了IP数据包的传输确认、丢失数据包的重新请求、将收到的数据包按照它们的发送次序重新装配的机制。<br>(1)TCP建立连接的3次握手：<br>第一次握手：客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;<br>第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>(2)TCP断开连接的4次挥手：<br>断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”<br>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了（当然，在FIN包之前发送出去的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK(fin+1)给对方。<br>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK(fin+1)给被动关闭方。</p>
<h3 id="udpuser-datagram-protocol用户数据报协议"><a href="#UDP-User-Datagram-Protocol用户数据报协议" class="headerlink" title="UDP(User Datagram Protocol用户数据报协议)"></a>UDP(User Datagram Protocol用户数据报协议)</h3><p>UDP也建立在IP之上，但它是一种无连接协议，所以不保证数据的传输，也不提供重新排列次序或重新请求的功能，所以说它是不可靠的。<br>UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的.<br>通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。比如我们聊天用的ICQ和QQ就是使用的UDP协议。</p>
<h3 id="tcp和udp区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><p>1、TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性;而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。<br>2、也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。<br>知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证，即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。</p>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>建立、管理和终止会话(会话协议数据单元 SPDU)</p>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>对数据进行翻译、加密和压缩(表示协议数据单元 PPDU)</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>允许访问 OSI 环境的手段(应用协议数据单元 APDU)<br>我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。如果想要使传输的数据有意义，则必须使用到应用层协议。<br>常见的应用层协议有：HTTP、FTP、Telnet、SMTP和Gopher等。</p>
<h3 id="http"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。HTTP协议又是基于传输层的TCP协议的<br>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p>
<h4 id="http报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><h5 id="请求报文"><a href="#请求报文：" class="headerlink" title="请求报文："></a>请求报文：</h5><img src="/2017/04/11/计算机网络协议/http_request_format.png" alt="http_request_format.png" title="">
<h5 id="响应报文"><a href="#响应报文：" class="headerlink" title="响应报文："></a>响应报文：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</div><div class="line">Content-Type: text/html;charset=ISO-8859-1</div><div class="line">Content-Length: 122</div><div class="line"></div><div class="line">＜html＞</div><div class="line">	＜head＞</div><div class="line">		＜title＞Wrox Homepage＜/title＞</div><div class="line">	＜/head＞</div><div class="line">	＜body＞</div><div class="line">		＜!-- body code --＞</div><div class="line">	＜/body＞</div><div class="line">＜/html＞</div></pre></td></tr></table></figure>
<p>其格式为：<br>＜status-line＞<br>＜headers＞<br>＜blank line＞<br>[＜response-body＞]<br>HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。<br>状态行（status line）通过提供一个状态码来说明所请求的资源情况。<br>状态行格式：HTTP-Version Status-Code Reason-Phrase CRLF<br>状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：<br>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求<br>常见状态代码、状态描述的说明如下：<br>200 OK：客户端请求成功。<br>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。<br>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。<br>403 Forbidden：服务器收到请求，但是拒绝提供服务。<br>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。<br>500 Internal Server Error：服务器发生不可预期的错误。<br>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）</p>
<h4 id="get与post的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h4><p>(1)GET中，请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中），以?分割URL和传输数据，多个参数用&amp;连接，e.g. login.action?name=mozi&amp;password=123。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出像%E4%BD%A0%E5%A5%BD的字符串，其中％XX中的XX为该符号以16进制表示的ASCII。而在POST中，把提交的数据放置在是HTTP包的包体＜request-body＞中。因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。<br>(2)数据大小：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：<br>GET：特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。<br>POST：由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。<br>(3)POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。</p>
<h3 id="ftp文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP(文件传输协议)"></a>FTP(文件传输协议)</h3><h2 id="socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>socket则是对TCP/IP协议的封装和应用(程序员层面上)，Socket本身并不是协议，而是一个调用接口(API)。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。</p>
<h3 id="利用socket建立网络连接的步骤"><a href="#利用Socket建立网络连接的步骤" class="headerlink" title="利用Socket建立网络连接的步骤"></a>利用Socket建立网络连接的步骤</h3><p>Socket的建立至少需要两个，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。<br>1、服务器监听：ServerSocket并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。<br>2、客户端请求：ClientSocket提出连接请求，要连接的目标是ServerSocket。为此，客户端的套接字必须提供服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，开一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/11/计算机网络协议/" data-id="cj4ob7fwd00101me9olgaj57n" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-c-虚函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/08/c-虚函数/" class="article-date">
  <time datetime="2017-04-07T16:39:50.000Z" itemprop="datePublished">2017-04-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/08/c-虚函数/">c++虚函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要对c++虚函数与多态进行归纳总结。</p>
<p>c++虚函数主要是用来实现多态。直观上来说就是new一个子类并赋值给父指针，然后通过父指针调用子类方法。如下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">string</span> str = <span class="string">"parent"</span>, str1 = <span class="string">"parent"</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"using Parent::fun()\nstr is "</span> &lt;&lt; str &lt;&lt; <span class="string">"\nstr1 is "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Child : <span class="keyword">public</span> Parent&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">string</span> str1 = <span class="string">"child"</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"using Child::fun()\nstr is "</span> &lt;&lt; str &lt;&lt; <span class="string">"\nstr1 is "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Parent *p = <span class="keyword">new</span> Child();</div><div class="line">    p-&gt;fun();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种让父指针p有多态属性的技术叫“泛型”，通过不更改类的代码来更改p的功能、方法。<br>(1)在添加virtual前，编译器会提示warning: Child::fun遮蔽了Parent::fun，但是加上virtual后就不再提示。<br>(2)编译器会为每个有虚函数的类创建一个虚函数表（编译的时候），该虚函数表将被该类的所有对象共享。类的每个虚成员占据虚函数表中的一行。如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小。</p>
<h2 id="动态绑定与静态绑定"><a href="#动态绑定与静态绑定" class="headerlink" title="动态绑定与静态绑定"></a>动态绑定与静态绑定</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/08/c-虚函数/" data-id="cj4ob7fw1000l1me9wer4ah79" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-c-继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/08/c-继承/" class="article-date">
  <time datetime="2017-04-07T16:00:04.000Z" itemprop="datePublished">2017-04-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/08/c-继承/">c++继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是对关于c++继承的知识点的总结</p>
<p>c++面向对象的三特征之一：继承，表示类与类之间的关系，可以理解为父类向子类share某些成员与函数。</p>
<p>继承的优势：<br>1.减少代码，方便维护，增加可读性。<br>2.增加类之间的关系与约束，增强逻辑关系。</p>
<p>如Student继承People，那么Student自然有People的所有属性与方法，不需重新写；当这些属性与方法有所修改，只需要更改People中的代码，则Student中的代码将被自动修改。</p>
<p>继承的语法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Student: <span class="keyword">public</span> People</div></pre></td></tr></table></figure></p>
<h2 id="继承的权限"><a href="#继承的权限" class="headerlink" title="继承的权限"></a>继承的权限</h2><p>上例中，public是公有继承的意思，当然也有private（默认）与protected，不过比较少用。<br>这些继承方法用来指定被继承的成员、方法的最高访问权限：</p>
<table>
<thead>
<tr>
<th>继承方式</th>
<th>父类成员的访问权限 → 子类成员的访问权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>public → public; protected → protected; private → 不能使用</td>
</tr>
<tr>
<td>protected</td>
<td>public → protected; protected → protected; private → 不能使用</td>
</tr>
<tr>
<td>private</td>
<td>public → private; protected → private; private → 不能使用</td>
</tr>
</tbody>
</table>
<p>(1)虽然父类的private成员不能在派生类中使用，但实际上父类的private成员也在子类中继承，只是不可见，但依然会占用子类对象的内存。<br>(2)子类要访问父类的private成员，只能使用父类的非private函数来访问。</p>
<h2 id="继承时的名字遮蔽"><a href="#继承时的名字遮蔽" class="headerlink" title="继承时的名字遮蔽"></a>继承时的名字遮蔽</h2><p>若子类和父类有同名函数fun()，则子类对象调用fun()时，只使用子类的fun()，这时父类的fun()就被遮蔽了。但子类对象同样可以用父类名字访问fun()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Parent &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="built_in">string</span> str = <span class="string">"parent"</span>, str1 = <span class="string">"parent"</span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"using Parent::fun()\nstr is "</span> &lt;&lt; str &lt;&lt; <span class="string">"\nstr1 is "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"using Parent::fun(int)\nstr is "</span> &lt;&lt; str &lt;&lt; <span class="string">"\nstr1 is "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Child : <span class="keyword">public</span> Parent&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="built_in">string</span> str1 = <span class="string">"child"</span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"using Child::fun()\nstr is "</span> &lt;&lt; str &lt;&lt; <span class="string">"\nstr1 is "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	Child c;</div><div class="line">	c.fun();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为：<br>using Child::fun()<br>str is parent<br>str1 is child<br>(1)Child中，str1对Parent::str1遮蔽，且继承了Parent::str<br>(2)这时编译器会有warning: Function ‘fun’ hides a non-virtual function from class Parent<br>(3)Child中fun不仅遮蔽了Parent::fun()，而且遮蔽了Parent::fun(int)，若此时我们在c.fun()中加入int参数，编辑器会报错Too mang arguments, expected 0，意味着Child中只能使用fun()。因此只要子类和父类有同名函数，子类函数都会将父类函数遮蔽，不论参数列表是否相同。<br>(4)当然，子类要调用父类函数很简单：只需使用c.Parent::fun()或c.Parent::fun(1);</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/08/c-继承/" data-id="cj4ob7fvu000k1me96o5gzgvr" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Collection-Map及其相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/07/Collection-Map及其相关/" class="article-date">
  <time datetime="2017-04-06T16:28:20.000Z" itemprop="datePublished">2017-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/07/Collection-Map及其相关/">Collection-Map及其相关(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文归纳Collection和Map的相关类的源码归纳</p>
<p>本文包含以下类的源码分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line"><span class="title">public</span> <span class="title">interface</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line"><span class="title">public</span> <span class="title">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div><div class="line"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line"><span class="title">public</span> <span class="title">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div></pre></td></tr></table></figure></p>
<h2 id="1collection"><a href="#1-Collection" class="headerlink" title="1.Collection"></a>1.Collection</h2><p>public interface Collection<e> extends Iterable<e><br>Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的”子接口”如List和Set。<br>方法：</e></e></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>int size()</td>
<td></td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td></td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td></td>
</tr>
<tr>
<td>Iterator<e> iterator()</e></td>
<td></td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td></td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
<td></td>
</tr>
<tr>
<td>boolean add(E e)</td>
<td></td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td></td>
</tr>
<tr>
<td>boolean containsAll(Collection&lt;?&gt; c)</td>
<td></td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td></td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c)</td>
<td></td>
</tr>
<tr>
<td>default boolean removeIf(Predicate&lt;? super E&gt; filter)</td>
<td>return true if any elements were removed</td>
</tr>
<tr>
<td>boolean retainAll(Collection&lt;?&gt; c)</td>
<td>只保留在c中的元素</td>
</tr>
<tr>
<td>void clear()</td>
</tr>
</tbody>
</table>
<p>(1)所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个 Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素，相当于深复制。下文省略对其构造函数的描述。<br>(2)Collection中没有get、set方法，get、set方法由子类List声明。<br>(3)而Collection靠引入Iterator来提供遍历方法:<br>public interface Iterator<e></e></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean hasNext()</td>
<td></td>
</tr>
<tr>
<td>E next()</td>
<td></td>
</tr>
<tr>
<td>default void remove()</td>
<td>throw new UnsupportedOperationException(“remove”)</td>
</tr>
</tbody>
</table>
<p>Iterator的遍历：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Iterator it = collection.iterator(); <span class="comment">// 获得一个迭代子</span></div><div class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">	Object obj = it.next(); <span class="comment">// 得到下一个元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(4)但是Collection的iterator只提供遍历的方法，没有使用Iterator来修改数据，且其remove函数只跑出错误，需要其子类来重写。</p>
<h2 id="2abstractcollection"><a href="#2-AbstractCollection" class="headerlink" title="2.AbstractCollection"></a>2.AbstractCollection</h2><p>public abstract class AbstractCollection<e> implements Collection<e></e></e></p>
<p>AbstractCollection使用Iterator实现了Collection中的这些接口：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>public boolean isEmpty()</td>
<td>return size() == 0</td>
</tr>
<tr>
<td>public boolean contains(Object o)</td>
<td>用iterator实现</td>
</tr>
<tr>
<td>public Object[] toArray()</td>
<td>用iterator实现</td>
</tr>
<tr>
<td>public <t> T[] toArray(T[] a)</t></td>
<td>用iterator实现</td>
</tr>
<tr>
<td>public boolean add(E e)</td>
<td>throw new UnsupportedOperationException()</td>
</tr>
<tr>
<td>public boolean remove(Object o)</td>
<td>用iterator实现</td>
</tr>
<tr>
<td>public boolean containsAll(Collection&lt;?&gt; c)</td>
<td>用iterator实现</td>
</tr>
<tr>
<td>public boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td>用iterator实现</td>
</tr>
<tr>
<td>public boolean removeAll(Collection&lt;?&gt; c)</td>
<td>用iterator实现</td>
</tr>
<tr>
<td>public boolean retainAll(Collection&lt;?&gt; c)</td>
<td>用iterator实现</td>
</tr>
<tr>
<td>public void clear()</td>
<td>用iterator实现</td>
</tr>
<tr>
<td>public String toString()</td>
<td>用iterator实现</td>
</tr>
</tbody>
</table>
<p>(1)AbstractCollection依然没有声明/实现get、set方法；<br>(2)其用Iterator实现了多种修改数据的方法，但是其并没有修改Collection中的Iterator，因此Iterator中的remove依然是{throw new UnsupportedOperationException(“remove”);}；<br>(3)其add方法throw new UnsupportedOperationException()，需要其子类ArrayList中把add重写；<br>(4)java不允许直接实例化AbstractCollection，其构造函数为protected。</p>
<h2 id="3list"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h2><p>public interface List<e> extends Collection<e></e></e></p>
<p>List还是一个interface，其描述一个有序的Collection，而且比Collection新增了用index来操作数据的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td></td>
</tr>
<tr>
<td>default void replaceAll(UnaryOperator<e> operator)</e></td>
<td>用ListIterator</td>
</tr>
<tr>
<td>default void sort(Comparator&lt;? super E&gt; c)</td>
<td>用toArray转为Object[]、Arrays.sort再用ListIterator保存</td>
</tr>
<tr>
<td>E get(int index)</td>
<td></td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td></td>
</tr>
<tr>
<td>void add(int index, E element)</td>
<td></td>
</tr>
<tr>
<td>E remove(int index)</td>
<td></td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td></td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td></td>
</tr>
<tr>
<td>ListIterator<e> listIterator()</e></td>
<td></td>
</tr>
<tr>
<td>ListIterator<e> listIterator(int index)</e></td>
<td></td>
</tr>
<tr>
<td>List<e> subList(int fromIndex, int toIndex)</e></td>
</tr>
</tbody>
</table>
<p>(1)Unlike sets, lists typically allow duplicate elements<br>(2)allow null elements.（某些子类会禁止null）<br>(3)比Collection新增了用index来操作数据的方法，以及get、set、indexOf等方法。<br>(4)除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator允许add，set元素，还能向前或向后遍历。</p>
<p>public interface ListIterator<e> extends Iterator<e><br>ListIterator新增方法：</e></e></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean hasPrevious()</td>
<td></td>
</tr>
<tr>
<td>E previous()</td>
<td></td>
</tr>
<tr>
<td>int nextIndex()</td>
<td></td>
</tr>
<tr>
<td>int previousIndex()</td>
<td></td>
</tr>
<tr>
<td>void set(E e)</td>
<td></td>
</tr>
<tr>
<td>void add(E e)</td>
</tr>
</tbody>
</table>
<p>(5)用ListIterator实现了默认的replaceAll与sort方法。<br>(6)所有实现List的类都要实现Iterator与ListIterator。</p>
<h2 id="4abstractlist"><a href="#4-AbstractList" class="headerlink" title="4.AbstractList"></a>4.AbstractList</h2><p>public abstract class AbstractList<e> extends AbstractCollection<e> implements List<e><br>实现了List接口的以下方法：</e></e></e></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>public boolean add(E e)</td>
<td></td>
</tr>
<tr>
<td>public E set(int index, E element)</td>
<td>throw new UnsupportedOperationException()</td>
</tr>
<tr>
<td>public void add(int index, E element)</td>
<td>throw new UnsupportedOperationException()</td>
</tr>
<tr>
<td>public E remove(int index)</td>
<td>throw new UnsupportedOperationException()</td>
</tr>
<tr>
<td>public int indexOf(Object o)</td>
<td>用ListIterator</td>
</tr>
<tr>
<td>public int lastIndexOf(Object o)</td>
<td>同上</td>
</tr>
<tr>
<td>public void clear()</td>
<td>removeRange(0, size())</td>
</tr>
<tr>
<td>public boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td></td>
</tr>
<tr>
<td>public Iterator<e> iterator()</e></td>
<td>return new Itr()</td>
</tr>
<tr>
<td>public ListIterator<e> listIterator()</e></td>
<td>return listIterator(0)</td>
</tr>
<tr>
<td>public ListIterator<e> listIterator(final int index)</e></td>
<td></td>
</tr>
<tr>
<td>public List<e> subList(int fromIndex, int toIndex)</e></td>
<td></td>
</tr>
<tr>
<td>public boolean equals(Object o)</td>
<td>重写，用ListIterator实现</td>
</tr>
<tr>
<td>public int hashCode()</td>
<td>重写</td>
</tr>
<tr>
<td>protected void removeRange(int fromIndex, int toIndex)</td>
<td>用ListIterator实现</td>
</tr>
</tbody>
</table>
<p>并新增方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>abstract public E get(int index)</td>
</tr>
</tbody>
</table>
<p>AbstractList首次引入modCount变量，以及<br>protected transient int modCount = 0;<br>来表示修改的次数，</p>
<p>(1)其set、add、remove函数均抛出错误，get函数只作了声明，这些都需要其子类来修改。<br>(2)不再使用原Collection中的Iterator，而是新建了内部类：<br>private class Itr implements Iterator<e><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">   <span class="keyword">int</span> cursor = <span class="number">0</span>; <span class="comment">//Index of element to be returned by subsequent call to next.</span></div><div class="line">   <span class="keyword">int</span> lastRet = -<span class="number">1</span>;<span class="comment">//element Index returned by most recent call to next or previous</span></div><div class="line">   <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//检测modCount在Iterator操作中不变</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> cursor != size();&#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">       checkForComodification();</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           E next = get(cursor);</div><div class="line">           lastRet = cursor;</div><div class="line">           cursor++;</div><div class="line">           <span class="keyword">return</span> next;</div><div class="line">       &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">           checkForComodification();</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">       checkForComodification();</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           AbstractList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">           <span class="keyword">if</span> (lastRet &lt; cursor)</div><div class="line">               cursor--;</div><div class="line">           lastRet = -<span class="number">1</span>;</div><div class="line">           expectedModCount = modCount;</div><div class="line">       &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></e></p>
<p>注意不能在iterator遍历时中用abstractlist.remove()，要用iterator内置的remove。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;Integer&gt; iterator = abstractlist.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">    Integer integer = iterator.next();</div><div class="line">    abstractlist.remove(integer); <span class="comment">//没有更新cursor和lastRet</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码是错误的，因abstractlist.remove不会改变cursor与lastRet的值，而会改变modCount。<br>在第二次使用hasNext时因修改了size，所以还是会返回true，但第二次iterator.next()时会有ConcurrentModificationException，这种情况相当于在iterator循环的同时有别的线程更改了abstractlist。<br>因此我们需要用Iterator.remove来删除Iterator的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;Integer&gt; iterator = abstractlist.iterator();</div><div class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</div><div class="line">    Integer integer = iterator.next();</div><div class="line">    iterator.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意必须要用next获取当前值后才remove当前值，hasNext并不移动游标cursor。<br>(3)ListItr:<br>private class ListItr extends Itr implements ListIterator<e><br>是在Itr上扩展了previous指针，实现原理与Itr相同。其实现了ListIterator中的下列方法：</e></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ListItr(int index)</td>
<td>cursor = index</td>
</tr>
<tr>
<td>public boolean hasPrevious()</td>
<td>cursor != 0</td>
</tr>
<tr>
<td>public E previous()</td>
<td>修改lastRet、cursor，并用AbstractList中没实现的get方法</td>
</tr>
<tr>
<td>public int nextIndex()</td>
<td>return cursor</td>
</tr>
<tr>
<td>public int previousIndex()</td>
<td>return cursor-1</td>
</tr>
<tr>
<td>public void set(E e)</td>
<td>使用AbstractList中的set方法，并修改expectedModCount的值</td>
</tr>
<tr>
<td>public void add(E e)</td>
<td>使用AbstractList中的add方法，并修改其维护的各个值</td>
</tr>
</tbody>
</table>
<p>(4)removeRange方法是protected的，必须要用clear方法来删除一个范围内元素，或subList(a,b).clear()</p>
<h2 id="5arraylist"><a href="#5-ArrayList" class="headerlink" title="5.ArrayList"></a>5.ArrayList</h2><p>public class ArrayList<e> extends AbstractList<e> implements List<e>, RandomAccess, Cloneable, java.io.Serializable<br>本质是一个变长的数组。<br>其维护size，Object[] elementData，DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}, DEFAULT_CAPACITY = 10, modCount = 0（来自AbstractList）。<br>实现了一下函数：</e></e></e></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList(int initialCapacity)</td>
<td>initialCapacity是初始elementData的大小</td>
</tr>
<tr>
<td>ArrayList()</td>
<td>elementData初始值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA</td>
</tr>
<tr>
<td>ArrayList(Collection&lt;? extends E&gt; c)</td>
<td></td>
</tr>
<tr>
<td>void trimToSize()</td>
<td>令capacity或elementData的长度为size</td>
</tr>
<tr>
<td>int size()</td>
<td>直接return size</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td></td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>return indexOf(o) &gt;= 0</td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td></td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td></td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td>浅复制</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>使用Arrays.copyOf开一个新的array</td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
<td>使用System.arraycopy</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>先做一个rangeCheck，可能抛出IndexOutOfBoundsException</td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td>同上，返回oldValue</td>
</tr>
<tr>
<td>boolean add(E e)</td>
<td>always true</td>
</tr>
<tr>
<td>void add(int index, E element)</td>
<td>先做rangeCheck，使用System.arraycopy复制</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>先做rangeCheck，使用System.arraycopy，返回oldValue</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td></td>
</tr>
<tr>
<td>void clear()</td>
<td>将所有元素设为null，不改变capacity</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td>使用System.arraycopy</td>
</tr>
<tr>
<td>boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td></td>
</tr>
<tr>
<td>void removeRange(int fromIndex, int toIndex)</td>
<td>protected</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c)</td>
<td></td>
</tr>
<tr>
<td>boolean retainAll(Collection&lt;?&gt; c)</td>
<td></td>
</tr>
<tr>
<td>ListIterator<e> listIterator(int index)</e></td>
<td>return new ListItr(index)</td>
</tr>
<tr>
<td>ListIterator<e> listIterator()</e></td>
<td>return new ListItr(0)</td>
</tr>
<tr>
<td>Iterator<e> iterator()</e></td>
<td>return new Itr()</td>
</tr>
<tr>
<td>List<e> subList(int fromIndex, int toIndex)</e></td>
<td>先做rangeCheck，return new SubList，与AbstractList相同</td>
</tr>
<tr>
<td>void forEach(Consumer&lt;? super E&gt; action)</td>
<td></td>
</tr>
<tr>
<td>boolean removeIf(Predicate&lt;? super E&gt; filter)</td>
<td></td>
</tr>
<tr>
<td>void replaceAll(UnaryOperator<e> operator)</e></td>
<td></td>
</tr>
<tr>
<td>void sort(Comparator&lt;? super E&gt; c)</td>
<td>用Arrays.sort</td>
</tr>
</tbody>
</table>
<p>private class Itr implements Iterator<e><br>的实现和AbstractList基本一样。区别只是ArrayList具体实现了get的方法，而AbstractList没有。而<br>private class ListItr extends Itr implements ListIterator<e><br>也是一样</e></e></p>
<p>private class SubList extends AbstractList<e> implements RandomAccess</e></p>
<p>(1)变长数组的实现：<br>当ArrayList为empty，elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，长度为0，size = 0；<br>当add第一个元素时，elementData的长度会变为DEFAULT_CAPACITY = 10，size为1，此时第二到第十个元素设为null。<br>当加入元素后长度超过当前elementData.length的时候，令capacity先为原来的1.5倍，若还不够大，就直接设为required的值。然后把原数组复制到一个长度为newCapacity的新数组内：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(2)ArrayList是线程不安全的:<br>其读写数组的函数都没有同步性质。<br>另在其iterator中加入了并发修改检验：即用modCount来判断当前是否出现并发修改异常。modCount表示elementData被修改的次数，在remove，add等方法中都会修改modCount，如果在iterator迭代中modCount有变，则认为有其他线程修改了原数组，报错。<br>(3)它允许所有元素，包括null<br>(4)size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。</p>
<h2 id="6linkedlist"><a href="#6-LinkedList" class="headerlink" title="6.LinkedList"></a>6.LinkedList</h2><p>public class LinkedList<e> extends AbstractSequentialList<e> implements List<e>, Deque<e>, Cloneable, java.io.Serializable</e></e></e></e></p>
<p>本质上是一个链表，链表结构体：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现的函数有：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>LinkedList()</td>
<td></td>
</tr>
<tr>
<td>LinkedList(Collection&lt;? extends E&gt; c)</td>
<td>使用addAll</td>
</tr>
<tr>
<td>E getFirst()</td>
<td></td>
</tr>
<tr>
<td>E getLast()</td>
<td></td>
</tr>
<tr>
<td>E removeFirst()</td>
<td>return first</td>
</tr>
<tr>
<td>E removeLast()</td>
<td>return last</td>
</tr>
<tr>
<td>void addFirst(E e)</td>
<td></td>
</tr>
<tr>
<td>void addLast(E e)</td>
<td></td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>return indexOf(o) != -1;</td>
</tr>
<tr>
<td>int size()</td>
<td></td>
</tr>
<tr>
<td>boolean add(E e)</td>
<td></td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td></td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td></td>
</tr>
<tr>
<td>boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td></td>
</tr>
<tr>
<td>void clear()</td>
<td></td>
</tr>
<tr>
<td>E get(int index)</td>
<td></td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td></td>
</tr>
<tr>
<td>void add(int index, E element)</td>
<td></td>
</tr>
<tr>
<td>E remove(int index)</td>
<td></td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td></td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td></td>
</tr>
<tr>
<td>E peek()</td>
<td>Retrieves, but does not remove, the head</td>
</tr>
<tr>
<td>E element()</td>
<td>Retrieves, but does not remove, the head</td>
</tr>
<tr>
<td>E poll()</td>
<td>Retrieves and removes the head</td>
</tr>
<tr>
<td>E remove()</td>
<td>Retrieves and removes the head</td>
</tr>
<tr>
<td>boolean offer(E e)</td>
<td>return add(e)</td>
</tr>
<tr>
<td>boolean offerFirst(E e)</td>
<td>addFirst(e)</td>
</tr>
<tr>
<td>boolean offerLast(E e)</td>
<td>addLast(e)</td>
</tr>
<tr>
<td>E peekFirst()</td>
<td></td>
</tr>
<tr>
<td>E peekLast()</td>
<td></td>
</tr>
<tr>
<td>E pollFirst()</td>
<td></td>
</tr>
<tr>
<td>E pollLast()</td>
<td></td>
</tr>
<tr>
<td>void push(E e)</td>
<td>addFirst(e)</td>
</tr>
<tr>
<td>E pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>boolean removeFirstOccurrence(Object o)</td>
<td>remove(o)</td>
</tr>
<tr>
<td>boolean removeLastOccurrence(Object o)</td>
<td></td>
</tr>
<tr>
<td>public ListIterator<e> listIterator(int index)</e></td>
<td>new ListItr(index)</td>
</tr>
<tr>
<td>public Iterator<e> descendingIterator()</e></td>
<td>new DescendingIterator();</td>
</tr>
<tr>
<td>Object clone()</td>
<td>浅复制</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>对象是新的，但是item元素是旧的</td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
</tr>
</tbody>
</table>
<p>(1)维护变量size，故size()只需O(1)时间。<br>(2)get, set, add, remove等使用index的方法均可能抛出IndexOutOfBoundsException<br>(3)维护Node<e>first与Node<e>last记录首尾<br>(4)维护modCount在ListItr检查并发修改。<br>(5)toArray的实现：<br>public Object[] toArray() {<br>    Object[] result = new Object[size];<br>    int i = 0;<br>    for (Node<e> x = first; x != null; x = x.next)<br>        result[i++] = x.item;<br>    return result;<br>}<br>(6)此外LinkedList提供额外的getFirst, getLast，removeFirst, removeLast，addFirst, addLast方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。<br>(7)LinkedList线程不安全，可用SynchronizedList：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list = Collections.synchronizedList(linkedList);</div></pre></td></tr></table></figure></e></e></e></p>
<p>(8)private class ListItr implements ListIterator<e><br>维护<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Node&lt;E&gt; lastReturned;</div><div class="line"><span class="keyword">private</span> Node&lt;E&gt; next;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</div></pre></td></tr></table></figure></e></p>
<p>方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ListItr(int index)</td>
<td>让index作为next</td>
</tr>
<tr>
<td>boolean hasNext()</td>
<td>nextIndex &lt; size</td>
</tr>
<tr>
<td>E next()</td>
<td>checkForComodification first</td>
</tr>
<tr>
<td>boolean hasPrevious()</td>
<td>nextIndex &gt; 0</td>
</tr>
<tr>
<td>E previous()</td>
<td>checkForComodification</td>
</tr>
<tr>
<td>int nextIndex()</td>
<td></td>
</tr>
<tr>
<td>int previousIndex()</td>
<td></td>
</tr>
<tr>
<td>void remove()</td>
<td>checkForComodification</td>
</tr>
<tr>
<td>void set(E e)</td>
<td>checkForComodification</td>
</tr>
<tr>
<td>void add(E e)</td>
<td>checkForComodification</td>
</tr>
<tr>
<td>void forEachRemaining(Consumer&lt;? super E&gt; action)</td>
<td>checkForComodification</td>
</tr>
</tbody>
</table>
<p>(9)private class DescendingIterator implements Iterator<e><br>与ListItr反向的Iterator</e></p>
<h2 id="7vector"><a href="#7-Vector" class="headerlink" title="7.Vector"></a>7.Vector</h2><p>public class Vector<e> extends AbstractList<e> implements List<e>, RandomAccess, Cloneable, java.io.Serializable</e></e></e></p>
<p>维护<br>protected Object[] elementData; //元素允许null，长度始终为capacity<br>protected int elementCount;<br>protected int capacityIncrement;</p>
<p>(1)本质上是一个同步的ArrayList。<br>(2)变长数组的实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ? capacityIncrement : oldCapacity);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如无定义capacityIncrement，则当达到当前capacity上限时，就capacity * 2，如有定义，直接加capacityIncrement。如capacity还不满足，则直接设为满足的，最后复制数组<br>(3)private class Itr implements Iterator<e>与<br>final class ListItr extends Itr implements ListIterator<e><br>是和ArrayList一样的，但加了同步。</e></e></p>
<h2 id="8stack"><a href="#8-Stack" class="headerlink" title="8.Stack"></a>8.Stack</h2><p>public class Stack<e> extends Vector<e></e></e></p>
<p>(1)是一种Vector，故也是同步的。<br>(2)栈顶是数组的尾。<br>方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>E push(E item)</td>
<td>addElement(item);return item;</td>
</tr>
<tr>
<td>synchronized E pop()</td>
<td>peek and remove</td>
</tr>
<tr>
<td>synchronized E peek()</td>
<td>peek but not remove</td>
</tr>
<tr>
<td>boolean empty()</td>
<td></td>
</tr>
<tr>
<td>synchronized int search(Object o)</td>
<td>相当于indexOf</td>
</tr>
</tbody>
</table>
<h2 id="9set"><a href="#9-Set" class="headerlink" title="9.Set"></a>9.Set</h2><p>public interface Set<e> extends Collection<e><br>(1)集合中的对象不按特定的方式排序，并且没有重复对象。<br>(2)Set最多有一个null元素。<br>(3)方法与Collection基本一样，有基本方法，也有Iterator。<br>(4)Set接口主要实现了两类：<br>HashSet：用hashTable来存取，存取比较快。<br>TreeSet：实现SortedSet，存取查log(n)能排序。</e></e></p>
<h2 id="10abstractset"><a href="#10-AbstractSet" class="headerlink" title="10.AbstractSet"></a>10.AbstractSet</h2><p>public abstract class AbstractSet<e> extends AbstractCollection<e> implements Set<e><br>实现的方法：</e></e></e></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean equals(Object o)</td>
<td>containsAll((Collection&lt;?&gt;) o)</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>用Iterator，把所有元素的hashCode相加</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt; c)</td>
<td>用Iterator</td>
</tr>
</tbody>
</table>
<h2 id="11hashset"><a href="#11-HashSet" class="headerlink" title="11.HashSet"></a>11.HashSet</h2><p>public class HashSet<e> extends AbstractSet<e> implements Set<e>, Cloneable, java.io.Serializable</e></e></e></p>
<p>用hashMap实现，维护：<br>private transient HashMap<e,object> map;<br>private static final Object PRESENT = new Object();<br>Set元素作为map的key，PRESENT作为所有的value值。</e,object></p>
<p>实现方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashSet()</td>
<td>map = new HashMap&lt;&gt;();</td>
</tr>
<tr>
<td>HashSet(Collection&lt;? extends E&gt; c)</td>
<td>map = new HashMap&lt;&gt;(…);addAll(c);</td>
</tr>
<tr>
<td>HashSet(int initialCapacity, float loadFactor</td>
<td>map = new HashMap&lt;&gt;(initialCapacity, loadFactor)</td>
</tr>
<tr>
<td>HashSet(int initialCapacity)</td>
<td>map = new HashMap&lt;&gt;(initialCapacity);</td>
</tr>
<tr>
<td>Iterator<e> iterator()</e></td>
<td>return map.keySet().iterator();</td>
</tr>
<tr>
<td>int size()</td>
<td>map.size();</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>return map.isEmpty();</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>return map.containsKey(o);</td>
</tr>
<tr>
<td>boolean add(E e)</td>
<td>return map.put(e, PRESENT)==null;</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>return map.remove(o)==PRESENT;</td>
</tr>
<tr>
<td>void clear()</td>
<td>map.clear();</td>
</tr>
<tr>
<td>Object clone()</td>
<td>newSet.map = (HashMap<e, object="">) map.clone();</e,></td>
</tr>
</tbody>
</table>
<h2 id="12sortedset"><a href="#12-SortedSet" class="headerlink" title="12.SortedSet"></a>12.SortedSet</h2><p>public interface SortedSet<e> extends Set<e><br>接口有以下函数：</e></e></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Comparator&lt;? super E&gt; comparator();</td>
<td></td>
</tr>
<tr>
<td>SortedSet<e> subSet(E fromElement, E toElement);</e></td>
<td>符合范围的子集</td>
</tr>
<tr>
<td>SortedSet<e> headSet(E toElement);</e></td>
<td>符合范围的子集</td>
</tr>
<tr>
<td>SortedSet<e> tailSet(E fromElement);</e></td>
<td>符合范围的子集</td>
</tr>
<tr>
<td>E first();</td>
<td></td>
</tr>
<tr>
<td>E last();</td>
</tr>
</tbody>
</table>
<h2 id="13treeset"><a href="#13-TreeSet" class="headerlink" title="13.TreeSet"></a>13.TreeSet</h2><p>public class TreeSet<e> extends AbstractSet<e> implements NavigableSet<e>, Cloneable, java.io.Serializable</e></e></e></p>
<p>与HashSet类似，维护：<br>private transient NavigableMap<e,object> m;<br>private static final Object PRESENT = new Object();<br>将Set元素作为map的key，PRESENT作为value，之后全部交给NavigableMap(实际是TreeMap)处理</e,object></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>TreeSet()</td>
<td>this(new TreeMap<e,object>())</e,object></td>
</tr>
<tr>
<td>TreeSet(Comparator&lt;? super E&gt; comparator)</td>
<td>this(new TreeMap&lt;&gt;(comparator))</td>
</tr>
<tr>
<td>TreeSet(Collection&lt;? extends E&gt; c)</td>
<td>this();addAll(c);</td>
</tr>
<tr>
<td>TreeSet(SortedSet<e> s)</e></td>
<td>this(s.comparator());addAll(s);</td>
</tr>
<tr>
<td>Iterator<e> iterator()</e></td>
<td>return m.navigableKeySet().iterator();</td>
</tr>
<tr>
<td>Iterator<e> descendingIterator()</e></td>
<td>return m.descendingKeySet().iterator()</td>
</tr>
<tr>
<td>NavigableSet<e> descendingSet()</e></td>
<td>return new TreeSet&lt;&gt;(m.descendingMap());</td>
</tr>
<tr>
<td>int size()</td>
<td>return m.size();</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>return m.isEmpty();</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>return m.containsKey(o);</td>
</tr>
<tr>
<td>boolean add(E e)</td>
<td>return m.put(e, PRESENT)==null;</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>return m.remove(o)==PRESENT;</td>
</tr>
<tr>
<td>void clear()</td>
<td>m.clear();</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td></td>
</tr>
<tr>
<td>NavigableSet<e> subSet(E fromElement,boolean fromInclusive,E toElement,boolean toInclusive)</e></td>
<td>new TreeSet&lt;&gt;(m.subMap(fromElement,fromInclusive,toElement,toInclusive))</td>
</tr>
<tr>
<td>NavigableSet<e> headSet(E toElement,boolean inclusive)</e></td>
<td>new TreeSet&lt;&gt;(m.headMap(toElement,inclusive))</td>
</tr>
<tr>
<td>NavigableSet<e> tailSet(E fromElement,boolean inclusive)</e></td>
<td>new TreeSet&lt;&gt;(m.tailMap(fromElement,inclusive))</td>
</tr>
<tr>
<td>SortedSet<e>subSet(E fromElement,E toElement)</e></td>
<td>subSet(fromElement,true,toElement,false)</td>
</tr>
<tr>
<td>SortedSet<e> headSet(E toElement)</e></td>
<td>headSet(toElement, false)</td>
</tr>
<tr>
<td>SortedSet<e> tailSet(E fromElement)</e></td>
<td>tailSet(fromElement, true)</td>
</tr>
<tr>
<td>Comparator&lt;? super E&gt; comparator()</td>
<td>m.comparator()</td>
</tr>
<tr>
<td>E first()</td>
<td>m.firstKey()</td>
</tr>
<tr>
<td>E last()</td>
<td>m.lastKey()</td>
</tr>
<tr>
<td>E lower(E e)</td>
<td>m.lowerKey(e)</td>
</tr>
<tr>
<td>E floor(E e)</td>
<td>m.floorKey(e)</td>
</tr>
<tr>
<td>E ceiling(E e)</td>
<td>m.ceilingKey(e)</td>
</tr>
<tr>
<td>E higher(E e)</td>
<td>m.higherKey(e)</td>
</tr>
<tr>
<td>E pollFirst()</td>
<td>m.pollFirstEntry()</td>
</tr>
<tr>
<td>E pollLast()</td>
<td>m.pollLastEntry()</td>
</tr>
<tr>
<td>Object clone()</td>
<td></td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/07/Collection-Map及其相关/" data-id="cj4ob7fuf00031me9mllgj2dc" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Set/">Set</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Computational-Geometry" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/06/Computational-Geometry/" class="article-date">
  <time datetime="2017-04-06T05:48:03.000Z" itemprop="datePublished">2017-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/06/Computational-Geometry/">Computational Geometry</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="convex-hull凸包"><a href="#Convex-Hull（凸包）" class="headerlink" title="Convex Hull（凸包）"></a>Convex Hull（凸包）</h2><p>若S为平面上的点集{p1,p2,…,pn}，convex hull of S, denoted by conv(S)，是包含S的全部点的最小polygon。<br><img src="/2017/04/06/Computational-Geometry/convex_hull1.png" alt="convex_hull1.png" title=""></p>
<h3 id="grahams-scan"><a href="#Graham’s-Scan" class="headerlink" title="Graham’s Scan"></a>Graham’s Scan</h3><p>为简化为题，将平面旋转某个角度，使得任意两个点的x坐标都不同。<br>找出leftmost与rightmost的点，这两点将conv(S)分为upper hull和lower hull两部分。<br><img src="/2017/04/06/Computational-Geometry/convex_hull2.png" alt="convex_hull2.png" title=""><br>一次Graham’s scan可以找出upper hull，然后同理可得lower hull。<br>(1)将S按x坐标排序。<br>(2)从左到右scan S。初始化一个stack D。<br>(3)设r为下一个scan的点：<br>    (i)若D中为空，或只有一个点，则将r放入D。<br>    (ii)若D中有两个或以上的点，则设top的点是q，第二top的点是p，<br>        若p→q→r是右转，则将r放入D；<br>        若p→q→r是左转或直线，则将q pop出来，重复(i)到(ii)知道r被放入D中。<br>(4)遍历完S后D即为upper hull。<br><img src="/2017/04/06/Computational-Geometry/convex_hull3.png" alt="convex_hull3.png" title=""></p>
<p>右转的判断：<br>先求pq的直线方程y = k(x - px) + py, k = (qy - py) / (qx - px)。<br>然后把rx代入，判断k(rx - px) + py &gt; ry是否成立。<br>或者用行列式：<br><img src="/2017/04/06/Computational-Geometry/convex_hull4.png" alt="convex_hull4.png" title=""><br>Time complexity取决于排序时间，n log(n)。</p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>把S排序后分为左右两份，对每份计算其conv，之后合并。<br>设左半部分为S1，右半部分为S2，S1的rightmost的点是p，S2的leftmost的点是q。规定p在下面遍历中逆时针移动，q则顺时针移动。<br>(1)若r为q的下一个移动点，判断p→q→r是否右转，若否则q移动到r。不断重复直到p→q→r是右转。<br><img src="/2017/04/06/Computational-Geometry/convex_hull5.png" alt="convex_hull5.png" title=""><br>(2)移动p，另r为p的下一个移动点，若q→p→r是右转，若否则p移动到r。不断重复直到q→p→r不是右转。<br>(3)若不能再移动p或q了，则pq is the upper outer tangent of conv(S1) and conv(S2)。<br><img src="/2017/04/06/Computational-Geometry/convex_hull6.png" alt="convex_hull6.png" title=""><br>同理可得lower outer tangent of conv(S1) and conv(S2)。</p>
<p>Time Complexity: 合并需要O(n)，则整个算法需要n log(n)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/06/Computational-Geometry/" data-id="cj4ob7fum00051me96mp2ur6z" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Functional-Dependencies-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/05/Functional-Dependencies-2/" class="article-date">
  <time datetime="2017-04-05T08:14:24.000Z" itemprop="datePublished">2017-04-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DataBase/">DataBase</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/05/Functional-Dependencies-2/">Functional Dependencies(2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是对Functional Dependency的知识点归纳</p>
<p>Functional dependencies can be used to refine ER diagrams<br>e.g.若有FD：position → salary</p>
<table>
<thead>
<tr>
<th>EmployeeId</th>
<th>Position</th>
<th>Salary</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>clerk</td>
<td>2000</td>
</tr>
<tr>
<td>2</td>
<td>clerk</td>
<td>2000</td>
</tr>
<tr>
<td>3</td>
<td>manager</td>
<td>4000</td>
</tr>
<tr>
<td>4</td>
<td>manager</td>
<td>4000</td>
</tr>
</tbody>
</table>
<p>根据FD的定义，我们知道第2、4条tuple是redundant，因此应将(Position, Salary)另外放在一个table中，原table只需保留Position。</p>
<h2 id="decomposition"><a href="#Decomposition" class="headerlink" title="Decomposition"></a>Decomposition</h2><p>Normalization is the process of decomposing a relation schema R into smaller tables(fragments): R1, R2,…, Rn.<br>如：将上例分两个table: R1(EmployeeId, Position)和R2(Position, Salary), 再将R2中重复的tuple去掉。</p>
<p>一个好的database design有下列三个属性：</p>
<h3 id="lossless-decomposition"><a href="#Lossless-decomposition" class="headerlink" title="Lossless decomposition"></a>Lossless decomposition</h3><p>a decomposition of R into R1 and R2 is lossless (not lossy) if and only if the common attribute of R1 and R2 must be a candidate key for R1 or R2.<br>在上例中Position就是candidate key for R1(Position, Salary)</p>
<h3 id="dependency-preservation"><a href="#Dependency-preservation" class="headerlink" title="Dependency preservation"></a>Dependency preservation</h3><p>Dependencies should be preserved within each Ri , i.e., otherwise, checking updates for violation of functional dependencies may require computing joins, which is expensive.</p>
<p>The decomposition is dependency preserving if and only if (F1 ∪ F2 ∪…∪ Fn)+ = F+ (Fi是Ri对应的FD). 若不等，意味着会失去一些FD。</p>
<h3 id="good-form"><a href="#Good-form" class="headerlink" title="Good form"></a>Good form</h3><p>The fragments Ri should not involve redundancy. Roughly speaking, a table has redundancy if there is a FD where the LHS is not a key.</p>
<h4 id="1nf第一范式"><a href="#1NF（第一范式）" class="headerlink" title="1NF（第一范式）"></a>1NF（第一范式）</h4><p>If the domains of all attributes in a table contain only atomic values, then the table is in First Normal Form (1NF).<br>In other words, there are no nested tables, multi-valued attributes, or complex structures such as lists.<br>Relational tables are always in 1NF, according to the definition of the relational model.</p>
<p>第一范式是为了要排除重复组的出现，所采用的方法是要求数据库的每个列的值域都是由原子值组成；<br>每个字段的值都只能是单一值。</p>
<h4 id="2nf第二范式"><a href="#2NF（第二范式）" class="headerlink" title="2NF（第二范式）"></a>2NF（第二范式）</h4><p>Let R be a relation schema, with the set F of FDs. R is in 2NF if and only if for each FD: X → A in F+, then:<br>(1)A ∈ X (the FD is trivial), or<br>(2)X is not a proper subset(真子集) of a candidate key for R, or<br>(3)every attribute in A is prime (an attribute that is part of a candidate key)</p>
<p>一个数据表匹配第二范式当且仅当<br>(1)它匹配第一范式<br>(2)所有非键的attribute都一定是候选键中所有attribute的函数（可由candidate key的attribute完全决定，非partial dependency）<br><img src="/2017/04/05/Functional-Dependencies-2/2NF.png" alt="2NF.png" title=""><br>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是主属性只依赖于主关键字。<br>e.g. For FD: { {A→B}, {B→C} }, candidate key is {A}, thus:<br>(1) for {A→B}, {A} is the only candidate key;<br>(2) for {B→C}, {B} is not a proper subset of candidate key {A};<br>对于其他的FD，其LHS只能是A、B的组合，所以也同理可得。<br>So this scheme is in 2NF.</p>
<h4 id="3nf第三范式"><a href="#3NF（第三范式）" class="headerlink" title="3NF（第三范式）"></a>3NF（第三范式）</h4><p>Let R be a relation schema, with the set F of FDs. R is in 3NF if and only if for each FD: X → A in F+, then:<br>(1)A ∈ X(the FD is trivial), or<br>(2)X is a superkey for R (different from 2NF), or<br>(3)every attribute in A is prime.</p>
<p>In other words, for every FD that does not contain extraneous (useless) attributes, then:<br>(1)the LHS is a candidate key, or<br>(2)the RHS is a prime attribute, i.e., it is an attribute that is part of a candidate key</p>
<p>e.g.若R=(B,C,E), F = { {E}→{B}, {B,C}→{E} }, candidate key is {C,E} or {B,C}<br>(1)for {E}→{B}, B is a prime attribute;<br>(2)for {B,C}→{E}, {B,C} is a candidate key</p>
<p>一个数据表匹配第三范式当且仅当<br>(1)它匹配第二范式<br>(2)没有transitive functional dependency<br><img src="/2017/04/05/Functional-Dependencies-2/3NF.png" alt="3NF.png" title=""></p>
<p>3NF和2NF的不同：<br>2NF allows FDs where X is not part of any candidate key</p>
<p>3NF still has redundancy</p>
<h4 id="bcnfboyce-codd-normal-form"><a href="#BCNF-Boyce-Codd-Normal-Form" class="headerlink" title="BCNF(Boyce-Codd Normal Form)"></a>BCNF(Boyce-Codd Normal Form)</h4><p>Let R be a relation schema, with the set F of FDs. R is in BCNF if and only if for eachFD: X → A in F+, then<br>(1)A ∈ X (the FD is trivial), or<br>(2)X is a superkey for R</p>
<p>BCNF tables have no redundancy</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/05/Functional-Dependencies-2/" data-id="cj4ob7fuy00081me9vhowfb7z" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Functional-Dependencies-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/05/Functional-Dependencies-1/" class="article-date">
  <time datetime="2017-04-05T06:40:17.000Z" itemprop="datePublished">2017-04-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/DataBase/">DataBase</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/05/Functional-Dependencies-1/">Functional Dependencies(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是对Functional Dependency的知识点归纳</p>
<p>A functional dependency is a constraint between two sets of attributes in a relation from a database. In other words, functional dependency is a constraint that describes the relationship between attributes in a relation.</p>
<p>若R是一种关系表，X和Y都是attribute的集合，那么：<br>若X到Y的functional dependency存在（即X → Y，或X determines Y）等价于：若X适用于R，则Y也一定适用于R。</p>
<p>e.g.若存在关系表：PGStudent(sid, name, supervisor_id, specialization)，那么：<br>{supervisor_id} → {specialization}意味着<br>（1）若两学生有同一个supervisor，那他们的specialization也相同；<br>（2）但若supervisor不同，那么我们不能确定specialization。</p>
<h2 id="trivial"><a href="#trivial" class="headerlink" title="trivial"></a>trivial</h2><p>X → Y is trivial if Y is a subset of X. e.g.{A, B}→{A}<br>X → Y is non-trivial if Y ∩ X = ∅, e.g.{A}→{B}</p>
<h2 id="fd是key的另一种表示"><a href="#FD是key的另一种表示" class="headerlink" title="FD是key的另一种表示"></a>FD是key的另一种表示</h2><p>对PGStudent(sid, name, supervisor_id, specialization)来说，<br>{sid} → {name, supervisor_id, specialization}<br>A set of attributes that determines the entire tuple is a superkey<br>A minimal set of attributes that determines the entire tuple is a candidate key<br>If there are multiple candidate keys, the DB designer designates one as the primary key </p>
<h2 id="closure-of-a-set-of-functional-dependencyf"><a href="#Closure-of-a-set-of-functional-dependency-F" class="headerlink" title="Closure of a set of functional dependency(F+)"></a>Closure of a set of functional dependency(F+)</h2><p>The set of all functional dependencies logically implied by F is the closure of F.<br>使用Armstrong’s Axioms找出所有F+<br>(1)if Y ⊆ X, then X → Y (reflexivity)<br>(2)if X → Y, then ZX → ZY (augmentation)<br>(3)if X → Y and Y → Z, then X → Z (transitivity) </p>
<p>extend rules：<br>(1)If X → Y holds and X → Z holds, then X → YZ holds (union)<br>(2)If X → YZ holds, then X → Y holds and X → Z holds (decomposition)<br>(3)If X → Y holds and ZY → W holds, then ZX → W holds (pseudotransitivity)</p>
<h2 id="closure-of-attribute-set"><a href="#Closure-of-attribute-set" class="headerlink" title="Closure of attribute set"></a>Closure of attribute set</h2><p>The closure of X under F (X+) is the set of attributes that are functionally determined by X under F:<br>X → Y is in F+ ⇔ Y ⊆ X+<br>e.g.若R = {A,B,C,D,E,G}, F = { {A,B}→{C}, {C}→{A}, {B,C}→{D}, {A,C,D}→{B}, {D}→{E,G}, {B,E}→{C}, {C,G}→{B,D}, {C,E}→{A,G}}, 且X = {B,D}<br>迭代求X(n)：由X(n-1)的所有attribute所determine的attribute组成：<br>X(0) = {B,D};<br>X(1) = {B,D,E,G};<br>X(2) = {B,C,D,E,G};<br>X(3) = {A,B,C,D,E,G};<br>X(4) = X(3);<br>故X+ = X(4)</p>
<h2 id="redundancy-of-fd"><a href="#redundancy-of-FD" class="headerlink" title="redundancy of FD"></a>redundancy of FD</h2><h3 id="redundant-dependencies"><a href="#redundant-dependencies" class="headerlink" title="redundant dependencies:"></a>redundant dependencies:</h3><p>Sets of functional dependencies may have redundant dependencies that can be inferred from the others.<br>{A}→{C} is redundant in:{ {A}→{B}, {B}→{C}, {A}→{C} }</p>
<h3 id="redundant-attributes"><a href="#redundant-attributes" class="headerlink" title="redundant attributes"></a>redundant attributes</h3><p>There may be extraneous/redundant attributes on the LHS of a dependency:<br>Let α→β be a functional dependency in F. Attribute A is extraneous in α if F logically implies ( F - {α→β} ) ∪ { (α-A)→β }. 缺少A后依然可以用F来imply。<br>e.g. F = { {A}→{B}, {B}→{C}, {A,C}→{D} } can be simplified to { {A}→{B}, {B}→{C}, {A}→{D} }.</p>
<p>There may be extraneous/redundant attributes on the RHS of a dependency:<br>Let α→β be a functional dependency in F. Attribute A is extraneous in β if (F - {α→β} ) ∪ { α→(β-A) } logically implies F. 缺少A后依然可以imply F。<br>e.g. F = { {A}→{B}, {B}→{C}, {A}→{C,D} } can be simplified to { {A}→{B}, {B}→{C}, {A}→{D} }</p>
<h2 id="canonical-coverfc"><a href="#canonical-cover-Fc" class="headerlink" title="canonical cover(Fc)"></a>canonical cover(Fc)</h2><p>A canonical cover for F is a set of dependencies Fc such that<br>(1)F and Fc are equivalent<br>(2)Fc contains no redundancy<br>(3)Each left side of functional dependency in Fc is unique:<br>    For instance, if we have two FD, X → Y and X → Z, we convert them to X → YZ (union).</p>
<p>计算Fc：<br>不断迭代直到不再改变：<br>(1)union<br>(2)find redundant attribute and delete it.<br>F(0) = { A→BC, B→C, A→B, AB→C }(union)<br>F(1) = { A→BC, B→C, AB→C }(C is redundant in A→BC)<br>F(2) = { A→B, B→C, AB→C }(B is redundant in AB→C)<br>F(3) = { A→B, B→C, A→C }(union)<br>F(4) = { A→BC, B→C }(C is redundant in A→BC)<br>F(5) = { A→B, B→C }(C is redundant in A→BC)<br>Fc = F(5)</p>
<h3 id="若要check-if-a-is-redundant-in-α-of-αβ"><a href="#若要check-if-A-is-redundant-in-α-of-α→β" class="headerlink" title="若要check if A is redundant in α of α→β,"></a>若要check if A is redundant in α of α→β,</h3><p>(1)compute ({α} – A)+ using the dependencies in F<br>(2)if ({α} – A)+ contains A, then A is redundant</p>
<h3 id="若要check-if-b-is-redundant-in-β-of-αβ"><a href="#若要check-if-B-is-redundant-in-β-of-α→β" class="headerlink" title="若要check if B is redundant in β of α→β,"></a>若要check if B is redundant in β of α→β,</h3><p>(1)compute α+ using only the dependencies in F’ = (F - {α→β}) ∪ {α→(β-A)}<br>(2)if α+ contains B, then B is redundant</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mozi030.github.io/2017/04/05/Functional-Dependencies-1/" data-id="cj4ob7fv2000c1me9hxhn90e4" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Network/">Computer Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataBase/">DataBase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MST/">MST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maximum-Flow/">Maximum Flow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Set/">Set</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bitwise/">bitwise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graph/">graph</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/Collection/" style="font-size: 10px;">Collection</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/MST/" style="font-size: 10px;">MST</a> <a href="/tags/Maximum-Flow/" style="font-size: 10px;">Maximum Flow</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/bitwise/" style="font-size: 10px;">bitwise</a> <a href="/tags/graph/" style="font-size: 10px;">graph</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/04/图论-二/">图论(二)Maximum Flow</a>
          </li>
        
          <li>
            <a href="/2017/04/24/图论-一/">图论(一):BFS,DFS,MST,Dijkstra</a>
          </li>
        
          <li>
            <a href="/2017/04/19/数据库索引/">数据库索引</a>
          </li>
        
          <li>
            <a href="/2017/04/11/计算机网络协议/">计算机网络协议</a>
          </li>
        
          <li>
            <a href="/2017/04/08/c-虚函数/">c++虚函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Ziliang, Ken, Mo<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>